<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[管理培训总结]]></title>
    <url>%2F2017%2F12%2F26%2F%E6%96%B0%E4%BA%BA%E7%AE%A1%E7%90%86%E8%80%85%E5%9F%B9%E8%AE%AD-md%2F</url>
    <content type="text"><![CDATA[管理的核心任务这两天参加公司的管理新人培训,感觉收获很多. 然后, 根据相应的场景自动使用你的模式. 构建管理的决策树模型. 不论是软件工程, 管理工程, 都首先是一门科学,同时也是一门实践. 用理论模型来指导实际工作, 同时在实践中反馈改进自己的模型. 课程内容总结德鲁克提出了, 管理者的-管理核心五任务: 制定目标 组织 有效激励 培养他人 衡量(绩效评估,反馈) 新任管理者需要转型在担任团队管理者之前, 我们是个人业绩贡献者. 但是被提升为小团队负责人之后, 我们更多承担的角色是 团队负责人. 是需要整合团队的力量, 使用团队的杠杆: 个人贡献衡量 -&gt; 团队贡献衡量 工作内容:写代码 -&gt; 系统设计 + 需求沟通 + 团队沟通 被动沟通 -&gt; 主动和团队成员沟通 自我服务 -&gt; 为团队成员服务 引用GE VP Jaime Irick的谈话 刚开始进入商界的时候, 我的主要任务就是让自己做到最好. 想进入西点或者GE, 你必须是最好的. 可一旦成为一名领导之后, 你必须学会激励身边的人, **培养他们**, **并帮助他们改变自己**. 如果想成为一名领导者, 你必须完成这一转变, 并意识到领导的关键在于学会为自己的团队成员提供服务. 你越早意识到这一点, 就越快的成长为一名合格的领导者. 以上讲话的核心几点: 激励成员. 培养成员. 管理者本质是你成员的服务者. 高效授权四步法 明确任务 识别下属 任务沟通 后续跟进 明确任务接收任务的四种模型 4D模型 Do not do it. Delegate it. Do it. Delay it 识别下属按照意愿 和 能力, 划分为四个象限模块.对于D1 - D4不同阶段的员工, 应该采取不同的管理模型. 简单来说就是, 意愿强, 能力强的成员, 采取充分授权的模式. 能力弱或者意愿弱的成员, 采用更多的指导和教练的模式. 任务沟通 Why. 为什么做这个 What. 具体的任务是什么 How. 明确步骤和方法. 说明 重点 和 难点. Action. 明确步骤和具体的执行策略. Support. 提出激励和支持 如何进行一场高质量的谈话如何赞赏别人-STAR法则在什么场景(situation), 为了完成某种任务(task), 采取了什么任务, 达到了什么结果(result). 如何加强谈话的深度与广度两个问题: 还有什么吗? 为什么? 如何进行一个非常有饱满效果的讲话 魂 谈话的目标 骨 谈话的框架 肉 谈话的内容 色 谈话的情感 其他的分享:老师X分享一个中心管理既是一种科学,也是一种实践. 新任的管理者可能会遭遇的两个挑战 个人贡献者 -&gt; 团队贡献者. 多角度360度沟通. 两个重点 以身作则. 信守承诺. 四个办法 主动沟通 提升团队成员能力 时间管理 有效安排任务 关于写作的建议 没有输出就没有输入. (持续这方面的加强领域) 写作使人精确. (如何学会写作) 因为你做的是一件对的事情, 大家才跟着你. 推荐书籍 领导梯队 高效能人士的四原则 ChangeLog 12/26/17 完成初稿]]></content>
  </entry>
  <entry>
    <title><![CDATA[程序员效率提升的几点分享]]></title>
    <url>%2F2017%2F12%2F13%2Fproductive-tips%2F</url>
    <content type="text"><![CDATA[最近一段时间, 团队招了不少新阶的程序员, 大部分都是2年左右的工作经验. 有感于很多初级工程师在工作效率方面, 并不是很很高效, 于是在团队里面做了一个关于程序员效率方面的分享, 同时也分享了一些我一直在使用的工具.]]></content>
      <tags>
        <tag>工具</tag>
        <tag>效率</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow学习系列一]]></title>
    <url>%2F2017%2F08%2F04%2Ftensorflow-1%2F</url>
    <content type="text"><![CDATA[最近一年, 所谓的人工智能很火, 感觉有点像几年前的云计算的概念. 大概快到了一个能将学术成果转换到实际应用的零界点. 而目前推动人工智能背后的核心技术, 应该就是 深度学习 这一个机器学习分支了. 于是趁这一段时间, 公司组织架构调整的空白期, 集中初步学习了一下目前最后的开源深度学习框架 - tensorflow. 安装首先安装python环境, 没有的安装python2.7 或者 python3, 然后安装pip, python的依赖包安装软件. 然后使用pip安装 tensorflow. 一开始直接使用 pip install tensorflow, 会自动下载国外的官网的镜像软件, 发现速度奇慢无比, 大概只有清华大学开源软件镜像站 选择CPU计算单元, Mac版本, python2.7版本. Tensorflow1.2.1. 目前清华大学的镜像还没有最新的1.3版本. pip install \ -i https://pypi.tuna.tsinghua.edu.cn/simple/ \ https://mirrors.tuna.tsinghua.edu.cn/tensorflow/mac/cpu/tensorflow-1.2.1-py2-none-any.whl 期间, 总是遇到了一个问题.在安装的过程中最后总是报错, 报安装的时候临时权限不足. OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-lxA2I6-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/numpy-1.8.0rc1-py2.7.egg-info OSError: [Errno 1] Operation not permitted: &apos;/tmp OSError: [Errno 1] Operation not permitted: &apos;/tmp/xxxx&apos; 最后在网上搜索了一堆, MacOS 10.11.1中的默认Python的问题. 通过brew 安装新的python进行解决. 1brew install python 验证安装启动python命令行, 执行下面一段简单的python代码 123456789101112$ python...&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello = tf.constant('Hello, TensorFlow!')&gt;&gt;&gt; sess = tf.Session()&gt;&gt;&gt; print(sess.run(hello))Hello, TensorFlow!&gt;&gt;&gt; a = tf.constant(10)&gt;&gt;&gt; b = tf.constant(32)&gt;&gt;&gt; print(sess.run(a + b))42&gt;&gt;&gt; 如果正常运行, 那么tensorflow就说明已经安装好了. 参考tensorflow官网: https://www.tensorflow.org/versions/r0.12/get_started/os_setup tensorflow训练数据: https://github.com/sherjilozair/char-rnn-tensorflow 国外的安装说明: http://www.asimovinstitute.org/a-quick-guide-to-installing-tensorflow-on-mac-os/]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM线上OOM的一个模拟分析]]></title>
    <url>%2F2017%2F07%2F27%2Fjvm-ops%2F</url>
    <content type="text"><![CDATA[JVM线上运行的时候, 偶尔发生OOM事故. 这类问题有时候比较隐蔽, 业务RD往往不知道如何下手, 因为大部分泄露是缓慢进行的, 问题的代码很难定位. 这里我将使用一段简单易懂的代码, 来演示如何使用工具MAT来分析OOM发送的原因. 模拟一个代码分析首先,让我们来看一段代码: 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; List&lt;Object&gt; list = new ArrayList(); int i = 0; while (true) &#123; list.add(new OMObject()); System.out.println("loop: " + i++); &#125; &#125; public static class OMObject &#123; private byte[] OM_OBJECT; public OMObject() &#123; this.OM_OBJECT = new byte[1024 * 1024]; &#125; &#125; &#125; 这段代码很简单易懂, 一个List, 不断添加1M大小的对象,并且没有释放. 根据JVM GC可达性的回收原理, 执行的线程中可以到达的对象是无法回收的. 所以, 在经过一段运行时间之后, 这段代码肯定是要发生OOM的. 现在我们将代码黑盒,反过来思考这个问题, 当发生OOM的时候, 我们来找到发生事故的原因. 执行Java的代码命令在编译之后,我们执行下面的命令启动JVM进程. 1java -Xmx10m -Xms10m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDateStamps -Xloggc:./gc.log Test JVM的几个参数含义如下: -Xmx10m -Xms10m 将初始堆和最大堆都调整到10m,避免伸缩,一步到位设置堆大小为10M. -XX:+PrintGCDetails 打印出详细的GC日志. -XX:+PrintGCDateStamps 在GC日志签名加上时间戳. -Xloggc:./gc.log 将GC日志信息输出到 ./gc.log 下面 启动脚本, 执行结果如下: 123456789101112131415Daniel@DanieldeMacBook-Pro-2:~/tmp|master⚡⇒ java -Xmx10m -Xms10m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:+PrintGCDateStamps -Xloggc:./gc.log Testloop: 0loop: 1loop: 2loop: 3loop: 4loop: 5loop: 6java.lang.OutOfMemoryError: Java heap spaceDumping heap to java_pid84183.hprof ...Heap dump file created [8165277 bytes in 0.049 secs]Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at Test$OMObject.&lt;init&gt;(Test.java:18) at Test.main(Test.java:8) 从执行结果中可以看到, 发生了OOM. 同时, 因为我们发现当前目录下面增加了两个文件: 12-rw-r--r-- 1 Daniel staff 3.2K Jul 27 16:48 gc.log-rw------- 1 Daniel staff 5.2M Jul 27 16:48 java_pid86163.hprof 分析线索我们来分析下这两个文件. gc.log.gc.log 是我们的JVM的垃圾回收器的详细日志, 然后我们打开gc.log分析看下. 从gc日志中我们发现. 发生了多次FULL GC. 而且FULL GC的时候, old区也没有被回收: [ParOldGen: 4522K-&gt;4522K(7168K)]. 所以是产生了OOM, 但是具体是哪里引起的OOM, 还需要通过其他的路径继续深入分析. 内存转存dump文件接下来我们看java_pid86163.hprof 这个文件. 因为我们在Java启动的时候设置了 -XX:+HeapDumpOnOutOfMemoryError 命令, 这个命令会在JVM发生内存泄露的时候,记录下系统的部分运行状态，并将其存储在堆转储 (Heap Dump) 文件中. 86163是当时JVM的进程号. 因为是二进制文件, 分析dump下来的我们使用著名JVM 堆内存内存分析工具 Eclipse Memory Analyzer 来对 OOM转录下来的dump文件进行分析. 首先, 我们将 java_pid86163.hprof dump文件导入到 MAT中去 导入后, 我们进入到 Overview 首页之中, 有一个整体的Heap分析饼图. 从饼图中我们可以看到不同的类对象占用的heap的占比, 一般占用最多的类是有问题的. 从图中我们可以看到, 有一个main线程占用了7M大小的内存. 同时, mat也提供了的 Leak Analysis 进行内存泄露相应的分析. 点击trace进入后有一个提示: 123456 Thread Stackmain at java.lang.OutOfMemoryError.&lt;init&gt;()V (OutOfMemoryError.java:48) at Test$OMObject.&lt;init&gt;()V (Test.java:18) at Test.main([Ljava/lang/String;)V (Test.java:8) 提示线程栈溢出的地方, Test.java的18行.基本可以定位问题了. 同时可以继续点击泄露的栈, 查看是哪些地方引用对象 发现有一个ArrayList列表占用了大部分的内存. 列表里面的元素是 Test.OMObject. 到这里基本已经能找到问题了. 我们回到代码里面找到 OMObject类.查找使用的这个List. 总结面对线上的OOM问题, 关键是JVM进程启动的时候, 设置好相应的参数, 保留OOM的现场线索和整句, 包括详细的GC日志和发生OOM时候堆栈快照. 然后利用工具可视化分析出一般占用最多的对象是哪些, 然后逐步分析定位到发生OOM的代码块. 参考文档 https://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/index.html]]></content>
      <tags>
        <tag>工具</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[番茄工作法-笔记]]></title>
    <url>%2F2017%2F07%2F25%2Fpotato%2F</url>
    <content type="text"><![CDATA[这两天为了更好的实践番茄工作法, 又将 番茄工作法中文版 重新阅读学习了一遍, 以下是整理的相关笔记和内容. 番茄工作法框架图 时间的基本概念 时间具有连续性. 集中注意力, 提高效率 学习的时候, 大脑清醒, 思路清晰, 集中注意力 简化工具, 集中精力到你真正专注的事情上面. 番茄工作法目标 减少打断次数 提高判断力 充满热情并保持. 加快学习进度 番茄工作法的流程 计划 -&gt; 计划一天要做的事情 追踪 -&gt; 每天总结, 做过的事情, 保留原始记录, 进行分析 记录 -&gt; 记录一天的番茄使用效果. 分析 -&gt; 不断分析你的每天的效率, 看是否可以提高你的效率 可视化处理 -&gt; 使用可视化分析你的工作成果. 工具清单 计时器. 简单的计时器就可以. 我使用的是网上免费版本 番茄土豆. 详细地址:https://pomotodo.com/ TO DO LIST. 今天要做的清单,加一个额外紧急事情列表. 关注当下. Activity List. 所有的等待要做的活动清单. 所有要做的一个存储清单. 按照重要程序，可以之后重新放入到 TO DO LISTS. 如何处理番茄时间 番茄时间不可以被任何事情打断.如果番茄时间被某人或某 事强制打断，那么这个番茄时间就相当于白费了，应该重新开始这个番茄时间，就当这个番 茄时间从来没有开始过 这几分钟的休息时间里，脑子里不要再去想任何有关你工作事情，比如，不要和你的同 事谈论工作中的问题，不要去回复重要的电子邮件或打电话给客户等 每四个番茄时间后. 有一个长时间的休息. -&gt; 专注恢复你的精力. 起身喝杯水. 打杯咖啡 上个厕所 如果中间发生了干扰, 将打断放在队列里面, 主线程继续处理你的当前的番茄时间. 番茄工作法, 重要的部是完成任务的番茄数, 开始或者结束时间并不重要. 这正是真正努力的过程所在. 必须每天写工作报告. 工作了哪些事情. 使用了多少的番茄时间. 还有哪些可以改善. 不断进行个人的优化 和 处理. 记录每天每个任何花费了多少番茄时间 减少被打断的次数打断的因素很多, 主要分为 内部打断 和 外部打断 内部打断因素 打断如果出现, 那么这个番茄就自动废弃. 如果发生了打断, 可以将事情放到紧急额外的事情, 然后等番茄时间结束之后, 你再去处理这个紧急不重要的事情. 减少来自内部的打断，我们首先要做的是掌握打断的次数和打断的类型，重新审查这些 打断，接受它们，或安排它们，或删除它们，都取决于这些打断。 增加一个 计划外的紧急事件列表, 处理番茄工作时间中的额外事情. 可以记录当前番茄时间有什么内在因素干扰了你. 任务结束之后, 利用休息时间处理 或者 转移到 “Activity Inventory” 清单列表之中去. 或者直接删除掉. 外部打断因素 番茄时间内, 关掉即时通讯工具的干扰. 利用中间的休息时间处理 如果他人当面找你, 直接说现在比较忙. 可以25min之后主动找他.放在额外的事情清单里面 保护你的番茄: 快速记录事情，推迟事情，并写进日程表，询问打 断你的人是否同意。 减少来自外部的打断，我们要做的也是掌握打断的次数和打断的类型，与打断你的人商 量，并按照事情的紧急程度，把它安排进你的工作日程。 让打断变成任务 可以单独抽离一个番茄处理这些临时记录下来的所有打断任务. 制作一份休息时间表 制作一个休息和工作时间表. 严格区分休息和工作时间. 保护好自己的激情,灵感. 一轮四个番茄, 四个番茄之后一定要休息 15-30min, 让自己恢复到充足的精力. 使用番茄工作法的注意事项 简单依赖可靠. 只是用铅笔. 橡皮, 纸. 灵活控制休息时间的长短, 为长期的胜利打下基础. 通过番茄时间, 让人们增加对番茄时间的敏感度, 能度量时间, 形成一定的紧迫感, 才能促使人们集中注意力投入到真正重要的事情上. 番茄工作法首要的原则是 记录. 记录自己的时间番茄, 记录了时间番茄才能进行个人行为的改善. 时间的具体连续性刺激着人们的生产力和创造力. 番茄工作法强调，要把精力放在当前的番茄时间上，完成了，就跳到下一个番茄时间。 你的注意力要放在当下，而不是过去或者将来的空想. NOW AND HERE. 当下就是当下. NOW AND NOW. 利用番茄时间法则, 来不断提高自己的预估能力. 如果一项任务的估测值大于 5 到 7 个番茄，那么就打散它。小 的事情更容易理解，更容易进行估测. 将大任务拆分到每个小的任务, 然后在小的任务上集中突破处理. 完成 把复杂的事情简化的能力，即使你还是保持 原先的工作时长和休息时长，失效是不可避免 如果一项任务的估测值小于一个番茄，就把几个小任务组合成一个大任务。 作息时间表分为工作时间和空闲时间，那么在空闲时间我们就 不再需要番茄工作法了. 休息时间不需要番茄工作. 值得强调的是，休息必须是一种休息，它并不是简单地在 25 分钟响铃后停止工作，然 而脑子里还一直在思考工作。它必须是停下一切，只从事一些简单的事情 休息不足, 会导致思考障碍, 导致效率低下. 思考 严格区分休息时间 和 工作时间. 采用杠铃模式. 休息的时间绝对放松, 不思考工作的事情. 番茄的时间绝对专注, 不可以有任何的分心工作. 应该设立工作开始和结束的仪式. 每天的工作应该有一个非常明确的deadline. 有截止时间才有紧迫感, 才有有效率. 避免无意义和无效率的加班. 量化改进. 使用番茄工作法量化自己每天的工作产出, 持续推进和改善. 关键还是 坚持/ 量化/ 反馈.]]></content>
      <tags>
        <tag>工具</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wireshark学习笔记]]></title>
    <url>%2F2017%2F07%2F24%2Fwireshark-study-note%2F</url>
    <content type="text"><![CDATA[上周集中花时间学习了解了一下网络抓包工具 Wireshark, 一个非常强大的网络抓包工具, 而且是开源免费的. 通过wireshark工具对于之前学习了解到的计算机网络知识重新复习了一遍, 将之前书上的理论知识真正通过能够通过工具可视化落地理解, 并进而真正解决很多实际的网络问题. 建议大学的计算机课程, 应该在教授计算机网络这门课程的时候, 可以将这个工具作为实验传递给学生. Wireshark介绍下面是Wireshark的主界面: 功能区wiresahrk 提供了具体的功能区块跳转. 主要的几个功能: Analyze. 数据包的分析工具. Statistics. 对于抓到的数据包进行统计的分析的功能. 主要包括: IO流量统计/协议分层统计/HTTP协议状态码统计/对话统计/终端统计/报文长度统计/报文Ip地址统计等. 数据包列表区以列表的形式, 展示抓取到的网络数据包. 主要包括两个部门: 列表区列表区主要包括几个部分: No. 显示了数据包的序列号 Time. 发生的时间. 这个可以在 View -&gt; Time Display Format 里面进行转换. Source. 数据包的源IP地址 Destination. 请求的ip地址. Protocol. 请求的协议层. Length. 数据包的长度 Info. 数据包的概述. 不同的协议的简单概述是不同的. 过滤区过滤区 提供了按照相应的规则, 只显示或者抓取你关系的数据包. 常用的过滤规则包括: 根据ip地址过滤. ip.host == xxxxx. 过滤包括 xxxxx ip的地址的所有数据包 ip.src == xxxxx. 过滤来源ip地位为xxxx的数据包 ip.dst == xxxxx. 过滤目标地址为 xxxx的数据包 根据tcp状况分析. tcp.analysis.duplicate_ack 重复ack的数据包 tcp.analysis.retransmission 过滤是超时重传的数据包. tcp.analysis.out_of_order 过滤数据包乱序的情况 对于http协议过滤 http.response.code &gt;= 400. 过滤http请求返回码超过400的数据包. 过滤条件非常多, 想了解更多的过滤条件, 可以点击 过滤区 -&gt; Display Filter Expression. 查找设置更多的过滤条件. 网络协议分层区.非常重要的一个区域. 对于抓到的数据包可以看到一个http请求, 对于请求数据包, 按照TCP/IP的模型, 将数据分为几层. 物理层 数据链路层(Ehternet II协议) 网络层(IP协议) 传输层(TCP协议) 应用层(HTTP协议) 每一层点击进去都可以看到, Wireshark已经按照各个协议的规范, 进行了自动解析和说明. 点击查看不是很难,关键是了解各个层次协议所展示出来的含义. 让我们抓取一个http数据包, 然后逐个协议层分析. 物理层 &amp; 数据链路层物理层显示了这个祯的全部长度, 在这一层具体可以看到相关的信息:数据包长度为 692字节, 抓取的网卡为 en0. epoch时间. 祯的序列号为1064. 过滤的名称为HTTP. 过滤的规则为 http || tcp.port == 80 || http2数据链路层比较简单, 接收方物理mac地址为我的苹果电脑mac地址, 以 Apple_开头. 发送方为huaweiTe的路由器. 网络层开头为简单描述, IP协议为IPV4, IP源地址: 103.218.241.74. 目标地址为: 172.18.206.201.然后是具体的描述. 总共的长度, 校验和等. 传输层从截图可以看到, 传输层是 TCP的协议, 让我们看下TCP报文格式:从抓取的数据帧可以看到, 这个祯的 源端口:80, 目的端口: 59649. 序号: 8320, 确认号: 1223等关键信息. 可以和TCP的报文格式对应上. 应用层从图片中可以看到, 应用层的协议是 HTTP协议. 从http的返回报文头中可以看到以下信息: 协议版本号: http1.1. httpd的状态返回码: 200. 是否允许跨域资源共享: access-control-allow-origin. 服务端返回的 Access-Control-Allow-Origin: * 表明，该资源可以被任意外域访问. 关于CORS可以访问 CORS标准 cache-control 设置缓存机制. max-age: 600. 代表了请求的结果缓存有效时间为 600s. 具体的http报文头的设置详见 cache-control设置 Content-Encoding 设置的解压缩的协议, 这里采用的是 gzip Content-Type 设置了返回的内容格式, 这里是 text/html 的协议 Last-Modified 代表了请求的内容服务端的最新的修改时间 Server: 服务端的名称 Vary: 告诉缓存中间代理服务器根据什么判断请求资源是否需要更新. 可以参考这篇文章介绍Vary介绍. 这里只有根据 url 和 accept-encoding作为 hash来判断是否需要新的response. Transfer-Encoding: 设置传输编码为 分块编码(chunked).这个解释比较复杂, 详细可以参考: Transfer-Encoding介绍. Date: 响应日期 原始数据区以16进制显示抓取到的数据包, 一般很少用到这个区域. 选择抓包的网卡我们选择过滤条件, 这个很重要, 尤其是流量很大的情况下, 如果不选择过滤条件, 将会导致wireshark抓取所有的流量数据, 处理不过来, 导致假死. 所以应该精心设计, 只关注抓取关心的数据包. 另外是, 选择抓取的网卡, 这里我们选择wifi激活的网卡en0. tcpdump 命令结合使用一般线上服务的机器, 都是linux系统, 没有图形化显示界面, 所以你需要将线上的机器网络抓包数据通过 tcpdump 命令抓取down下来, 然后到本地使用 Wireshark工具图形化显示分析. 使用 tcpdump 抓取数据包. 关键参数 -s 和 -wtcpdump -i en0 -s 0 -w down.cap host 61.135.169.125 代表 抓取网卡en0. -s 代表抓取的长度. 代表每个数据帧从头开始抓取的长度. 如果设置0, 则代表抓取默认的 65535最大的长度. 这个长度需要仔细思考设计, 因为如果太长, 会导致抓包数据加到, 效率变低. 如果过短, 可能获取不到关键信息. host 61.135.169.125 代表抓取和ip地址为 61.135.169.125 所有主机交互. 也可以在tcpdump命令直接加上过滤条件, 在抓包的时候就进行过滤. 导入cap文件进行分析选择 文件夹 选型导入刚刚抓取到的问题件 down.cap 结束这里只是简单介绍了Wireshark的使用方法, 具体遇到很多的网络问题, 还是需要在熟悉理解网络基本协议的情况下, 依赖很多的case逐渐培养起解决网络问题的经验. 参考 EMC的网络基本功 https://www.gitbook.com/book/wizardforcel/network-basic Wireshark 网络分析就是这么简单. EMC的一个工程师专门讲解Wireshark的使用. 不错的入门书. CROS https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS]]></content>
      <tags>
        <tag>工具</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构-笔记]]></title>
    <url>%2F2017%2F07%2F19%2Frefactor-read%2F</url>
    <content type="text"><![CDATA[利用这段开发时间的空余, 又将 重构 这本书学习一遍, 以下是相应的学习笔记摘要. 重构概念重构定义对软件内部结构的一种调整, 目的是在不改变软件可观察行为的前提下, 提高其可理解性, 降低其修改成本. 不仅仅是修改代码, 更是一种高效并且受控的代码整理技术. 重构的目的 改进软件设计. 防止代码逐渐腐烂. 如果不一直维护, 代码将会逐渐加熵, 越来越复杂, 直到最终代码腐烂掉. 是代码更加容易理解. 写代码的时间, 远远低于代码维护的时间. 重构可以加快开发速度, 快速开发速度. -&gt; 加快开发速度. 随时重构 -&gt; 持续不断的进行重构. 事不过三, 三则重构 如果我纯粹是为了今天工作, 明天我将完全无法工作. 需要一个更加广阔的视角看待现在的编程工作. 本质:计算机科学是这样一门科学: 它相信所有问题都可以通过增加一个间接层来解决. 重构的本质是通过在不改变功能的情况下, 增加更多的逻辑分层, 达到简化.抽象 和 共用. 重构与性能原则: 先写出可以运行的软件, 然后再调整程序来获得足够的性能. 何时进行重构重复代码(Duplicate code)当idea提示, 有很多相同代码段的时候, 就需要认真考虑了. 过长函数(Long method) -&gt; 使用 extract method.短函数比长函数好. 程序越长越难以理解. 子程序需要额外的开销.最好不要让函数超过 50 行. 积极的分解函数.原则: 每当感觉需要注释来说明的时候, 我们就需要把说明的东西写入一个独立的函数 通过replace temp with query. 来消灭临时变量. 过多的临时变量, 将导致函数非常难以阅读. 逻辑表达式可以提炼成一个单独的函数. 循环语句可以提炼单独的一个函数. 过大的类 使用Extract Class 和 Extract SubClass 将多长类抽取出来. 过长的参数(Long Parameter List) 过多的变量抽取出总结成一个Class 测试-重构的基础 确保所有测试都能够完全自动化. 让他们检查自己的测试结果 不要再写print out 肉眼查看的 unit test了 写好一点功能之后, 就立即测试, 构筑全面的测试体系 测试你担心出错的部分,投入与产出比最大化. 主要的重构方法 Extract Method(抽取函数) Replace Temp with Query(以查询取代临时变量) 局部变量会使代码难以提炼 十有八九根本不会造成影响到任何性能问题 Inline Method(内联函数) Inline Temp(内联临时变量) Introce Explaining Variable(引入解释性变量) 表达式复杂而且难以阅读的时候使用 Split Temp Variable(分解临时变量) 每个临时变量应该只用来承担一个责任. 如果一个变量承担了多个责任, 应该申请多个临时变量 在对象之间进行搬迁(move field &amp; move method) 迁移函数(一个类有太多的函数 或者 代码太长), 可以再抽离一个类出来. 迁移变量 Extract Class(提炼类) Inline Class(将类内联化) Replace Magic Number with Symbolic Constant(通过字面常量取代法数) 取代类型码的各种重构方法 Replace Type code with Class(通过类的继承关系, 将类型码换掉) Replace Type code with Subclass(以子类取代类型码) 工厂方法创建子类 将不同type, 创建不同的子类. Replace Type code with State/Strategy 简化条件表达式 Decompose Conditional(分解条件表达式) -&gt; 抽取出单独一个方法进行封装 合并条件表达式(Consolidate Conditional Expression) 使用卫语句取代嵌套条件表达式(如果条件及其罕见,单独检查该条件) Introduce Null Object(引入Null 对象),备注: 可以用Guava的 Optional类来代替 简化函数调用 将修改函数 和 查询函数进行分离 将多个参数调用简化为一个对象调用(比如多个值传递,多个属性为同一个对象, 直接将对象作为参数传递即可) 使用工厂方法取代构造函数(Replace Constructor with Factory Method) 根据参数的个数和类型 -&gt; 选择不同的创建类型 将向下转型的工作封装在函数里面, 不需要将向上转型的任务交给客户端 使用异常取代错误码]]></content>
      <tags>
        <tag>软件</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[政治是达成目标的手段]]></title>
    <url>%2F2017%2F01%2F01%2Fgame%2F</url>
    <content type="text"><![CDATA[最近技术书籍看的少, 因为项目管理和很多协调的工作要做, 更多学习和阅读了一些管理,策略,政治方面软实力的书籍. 发现,不论什么类型的工作, 当你往上走的时候, 单独靠个人的单打独斗, 你的影响力总会限定在一定的范围之内. 这个时候, 组织，协调，沟通，管理等软技能的就非常重要了. 最近看了一本书, 叫做『硬球』, 作者是美国总统的讲稿的负责人, 深谙各种政治斗争的手段, 通过这一本书中大量的实例向我们生动的展示了这些政治家如果通过各种策略和手段而达成自己的目的. 我觉得不论是否是搞政治的人, 都需要学会一些政治手段, 正如这本书中提到的一句话, 『我们这里探讨的并不是什么政治哲学, 而是政治手段, 不是为什么, 而是怎么办』. 通过这些手段,并不是让你成为某种腹黑的人, 而是更好有效的达成你的目标. 要记住, 任何有人的地方就有江湖, 有江湖的地方就有斗争. 在任何组织之中, 政治都是不可避免的. 关键在于你要加入游戏, 通过政治手段来达到你的目标, 推动事情向前发展. 以下是书中的一些『金玉良言』吧, 分享以下. 导言 在这个所谓的核能时代, 政治是唯一供成人玩的游戏. 那些政治家本身都有一个共同的特点: 那就是他们对于竞争的热爱. 把你的朋友搞的多多的, 把你的敌人搞的少少的. 第一章 关键不在于人是谁, 而在想认识谁, 建立一对一的亲密关系 政治零售: 一对一的单独会面是最有可能获取对方的支持的. 一定要掌握一对一的基本沟通技巧. 最快的速度认识他们, 认识的越多越好. 要把全部的注意力集中到对方目前的处境上, 这是一种非常罕见的能力. 它能够让你相信, 你的问题不管在别人眼里多么微不足道, 对他而言却是最重要的. 在没有准备好弹药之前,绝对不要拿起枪炮. 政治就是挨家挨户推销保险. 第二章 一切政治都是乡土的 邻居丢了工作的时候就是经济不景气, 我们自己丢了工作就是大萧条了 “当你要给人们增加痛苦的时候，所有的痛苦都应一次性地迅速施加在他们头上，因为他们品味痛苦的时间越短，他们被激怒的程度也就越低。而另一方面，在给予人们好处的时候，却要一点一点地、逐步地给，因为只有在这样的连续不断的给予中，人们才能最大程度地感受到你的好处。” 第三章 索取比给予更好 不吝玉向人启齿求助是所有权利游戏中的最高境界. 你在一个人身上付出的越多, 你对他就会变得越来越忠诚. 如果你想交一个朋友, 最好的办法就是给他人优惠. 施恩和受惠一样都能使人产生义务感, 这是人的天性. “当你开口向别人求助的时候, 你隐含的意思就是让别人在你身上下赌注,你争取到越多的人下赌注, 你输掉的几率就越小. 然而, 很多人克制自己不愿启齿情人帮忙, 因为他们觉得等于承认弱小, 他们认为坚持依靠自我才是力量的象征. 这种”一切自己干”的心态, 是非常致命的. 当你向一个人提出请求时, 并不是等于你只是在要求他们付出, 你也要把他想要的东西给了他, 让他有机会参与你的事业, 创建你的股东网络. 有件事你需要明白: 人们喜欢别人求到他. 伟大的事业就像伟大的战争, 只要做出了牺牲, 就需要进一步牺牲. 不错, 她总是在突出自己, 不过干我们这一行就需要这个. 在权利的斗争之中, 最有效的手段就是敢于向别人提出要求. 第四章 与带你来的人共舞 对于职业政治家来说, 忠诚就如同道德操守一样, 是影响他们职业生涯的至关重要的品质. 没有人会相信一个变节的叛徒. 建立强大的联盟的途径 了解他人的兴趣和愿望 找出相应的道路建立对你有帮助的关系 用相互支持和互惠巩固这种关系 最重要的就是你要选对向谁效忠, 一旦你上了船, 你就很难做到无视船长的影响和存在了 第五章 总是让你的敌人站在你的面前 没有永远的敌人, 没有永远的朋友, 只有永远的利益 和你的朋友保持密切的关系, 但是你要记住, 你应该与你的敌人保持更密切的关系. 任何一个聪明的政治家都不会关上同自己那些敌人的对话和和解之门. 第六章 不要疯狂, 不要扯平, 而要全力推进 明智的政治家懂得与对手合作, 同化自己的敌人 不要浪费你的生命盯着汽车上的反光镜. 扯平比疯狂好, 推进比扯平更好 牢记你的目标, 不要疯狂, 不要扯平, 全力推动事情向前发展. Drive Drive Drive 第七章 对任何飞来之箭, 都要一一回击 对于别人的供给立刻反击, 不要给他们一丝成功的机会. 如何反击 在他们撒谎的时候毫不犹豫的当场击穿 奚落地方 第八章 说话是为了更好的沉默 沉默是一种武器 沉默, 专心倾听别人的谈话, 我从来都不会一无所获. 沉默有时候是一种比伶牙俐齿更为有效的武器, 吵闹喧嚣很少等同于真正的行动 一个谈判高手最珍贵的财富在于他有着难缠的名声. 为什么我必须妥协? 为什么我必须妥协? 记住: 永不妥协 火爆的脾气, 但是总能正确的加以运用. 第九章 永远对原则问题表示赞同 对他人的品味表示适当的尊敬和顺从, 通常意味着他会在利益问题上投桃报李. 并不是在某一项具体的事项上让步, 通过迎合反对者的口味并投其所好, 给人留下一个妥协者的映像. 聪明的人应该懂得不要一味纠缠于原则问题而要注重具体切实目标的达成.]]></content>
      <tags>
        <tag>管理</tag>
        <tag>策略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful API 利器 Swagger]]></title>
    <url>%2F2016%2F10%2F16%2Fswagger-intro%2F</url>
    <content type="text"><![CDATA[目前公司的项目对外交互都是采用 http resful的协议进行通信,数据格式采用 JSON RESTFUl的风格, 这种组合比较轻量级, 基本抛弃过去的xml格式. 但是在互联网后台服务中,都是采用分布式系统, 会将一个大的项目拆分成多个小的子系统, 每个团队各负责一个部分, 这个时候, 如何定义各系统的之间的接口以及如何就接口进行展示和沟通, 往往是一个头疼的问题. 之前的项目开发中, 一直采用纯粹的文档的形式, 随着业务的变化, 维护文档的更新是一个非常耗时耗力的事情. 这段时间看到了一个开源项目 swagger, 提供了一种从项目代码中自动生成接口文档的功能, 可以保持和代码的同步变化, 非常强大. 其中与Spring整合版本是Spring-Fox的开源项目, 已经和Spring框架进行了非常好的整合. 本文将对Swagger进行简单的一个介绍和Demo的实现. Swagger是什么Swagger是一系列RESTful API 的工具, 通过 Swagger 你可以获得项目的一种交互式文档, 客户端SDK的自动生成等功能. 我们从 Swagger Github 的官方主页摘录: The goal of Swagger™ is to define a standard, language-agnostic interface to REST APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. 所以, 不需要阅读源码和文档, 就可以让程序员和机器能够发现和理解服务的接口. Swagger提供的主要工具包括: Swagger CoreSwagger-core 是 Swagger的Java 实现. 是整个swagger工具的核心实现. Swagger Core是使用Java编程实现的. Swagger Codegen提供了根据swagger的接口定义文件(yaml形式), 直接生产相应的代码, 以一种命令行工具的形式 Swagger Editro通过Spring的 Swagger Editor, 使用yaml语言先定义简单的接口, 然后通过 Swagger-codergen 就可以自动生成 相应的 服务端 和 客户端的调用代码了. 具体的Swagger Editor的操作界面参考如下,swagger editor 使用操作步骤: 使用Yaml语言, 定义好API接口 点击 generate server code, 选择你要的语言, 就可以下载自动生成的相关接口的初始化项目了 点击 generate client code, 选择你要的语言, 就可以下载自动生成调用这个接口的 客户端代码了. 通过上面的功能, 我们发现, 项目初始化之后, 我们就可以通过swagger工具, 快速生成我们需要的初始化项目了, 大大加快了我们的项目开发进度. 这个比 springboot initialize 更加的方便. Swagger UISwagger UI 可以将你的项目接口自动生产具有交互的html页面, 是一个前端页面的自动生成项目. Swagger UI的 demo: swagger ui demo.Swagger UI的界面示意图: 还有其他一系列关于RESTful API的swagger工具, 具体的使用 可以参考相应的官方文档, 都是比较简单易懂的. 具体使用参考官方网站. Demo - SpringBoot项目中使用SwaggerSpringFox是一个自动检测和生成Spring 运行时的API接口 , SpringFox完全支持Swagger工具, 只要在 Spring的项目中引入相应的SpringFox-Swagger包, 就可以使用swagger一系列工具了. 具体的使用方法可以参考SpringFox的官方文档:https://springfox.github.io/springfox/docs/snapshot/. 下面我也将实现一个简单的SpringFox-Swagger的demo. 具体的Demo源代码已经上传到Github上:地址: https://github.com/DanielHit/demo-spring-swagger 引入 SpringFox-Swagger首先, 在已经有的SpringBoot项目中引入 SpringFox-Swagger包分别引入了 springfox-swagger-ui 和 springfox-swagger2 两个包, 目前最新的版本是 2.6.0. 12345678910111213&lt;!-- Swagger --&gt;&lt;!--springfox的基本信息文档: http://springfox.github.io/springfox/docs/current/#architecture--&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt;&lt;/dependency&gt; SpringBoot 支持 Swagger 在Application启动类中支持Swagger,增加@EnableSwagger2注解, 让SpringBoot项目支持 Swagger 12345678@SpringBootApplication@EnableSwagger2public class DemoSpringSwaggerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoSpringSwaggerApplication.class, args); &#125;&#125; 配置Swagger信息 配置Swagger接下来, 我们需要对我们的Swagger进行配置, 我们需要在我们的SpingBoot项目中增加一个Bean. Docket 是具体的配置类, 既可以使用 xml 配置, 也支持注解配置, 这里我们使用注解配置. 具体的Docket的doc: Docket. 其中最终的一些展示信息, 需要设置 Docket的apiInfo, ApiInfo包括: 1234567private final String version; // 接口版本号private final String title; // 接口大标题private final String description; // 具体的描述private final String termsOfServiceUrl; // 服务说明urlprivate final String license; // licenceprivate final String licenseUrl; // licnce urlprivate final Contact contact; // 接口作者联系方式 具体的配置类如下 Controller内容我们假定demo中开发了两个controller, 但是我们不希望将IgnoreController的接口信息暴露在自动生成的文档里面, 这时候我们可以在 这个controller上加一个注解 @SwaggerIgnore(PS: 这个注解是我们自己定义的), 在 SwaggerConfig增加一个配置, 通过注解忽略API. SwaggerConfig的配置信息 apis(not(withClassAnnotation(SwaggerIgnore.class))) //SwaggerIngore的注解的controller将会被忽略 SwaggerConfig的类的具体配置信息如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Configurationpublic class SwaggerConfig &#123; @Bean public Docket merchantStoreApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .groupName("internal-api") .genericModelSubstitutes(DeferredResult.class) .useDefaultResponseMessages(false) .forCodeGeneration(true) .pathMapping("/")// base，最终调用接口后会和paths拼接在一起 .select() .apis(not(withClassAnnotation(SwaggerIgnore.class))) //SwaggerIngore的注解的controller将会被忽略 .paths(or(regex("/api/.*"))) .build() .apiInapiInfo.(testApiInfo()); &#125; private ApiInfo testApiInfo() &#123; ApiInfo apiInfo = new ApiInfo("标题文档",//大标题 "文档的详细说",//小标题 "0.1",//版本 "NO terms of service", "razorer@razorer.com",//作者 "The Apache License, Version 2.0",//链接显示文字 "www.razorer.com"//网站链接 ); return apiInfo; &#125;&#125;``` 在 `IgnoreController`上增加注解 `SwaggerIgnore`.就可以了.`IgnoreController` 的配置```java@RestController@SwaggerIgnore //swagger根据这个注解, 将会忽略这个controller的接口@RequestMapping("/api/")public class IgnoreController &#123; @RequestMapping("/ignroe/controller") public UserModel ignoreUserModel() &#123; return new UserModel("fuck", 23); &#125;&#125; Demo运行结果 运行项目 1java -jar targe/demo-spring-swagger-0.0.1-SNAPSHOT.jar 接口文档展示样式成功启动项目之后, 就可以访问项目的API 接口信息了, 本地地址: http://localhost:8080/swagger-ui.html.结果应该是这样的: 总结Swagger是一款非常强大的RESTful API管理工具, 同时与现有的Spring各种框架有一个非常顺畅的集成, 有个Swagger API的工具之后, 将大大简化微服务中API的管理, 减少各个团队之间对于文档的管理 和 团队的沟通成本. 相关参考 Swagger的官方主页: SpringFox项目文档: http://swagger.io/getting-started-with-swagger-i-what-is-swagger/ SpringEditor的地址: http://editor.swagger.io/#/]]></content>
      <tags>
        <tag>编程</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件开发内功提升计划]]></title>
    <url>%2F2016%2F10%2F14%2Fdeep-tech-learn-plan%2F</url>
    <content type="text"><![CDATA[看金庸的小说里, 那些武功高手之所以能成为高手, 无一不都是所谓的『内功深厚』. 那么在软件开发领域, 我认为所谓的内功深厚, 就是应该对计算机的基础和底层有一个非常深刻和扎实的『自底向上』的知识结构, 而不仅仅是停留在 code just run的现象层面. 从这一点思考出发, 就发现自己的内功并不是很扎实, 为此,准备使用半年的时间回顾学习底层的基础知识, 制定了一个学习清单 并且也在在此列出, 更好的量化和督促自己. 根据目前的业界软件开发领域, 列出了所依赖的几大基础领域, 其实也是 我们大学计算机系的几大基础课程清单吧. 列表如下: 操作系统 数据库 Java虚拟机 计算机网络 分布式系统 然后各个系列根据各自领域相关人士的推荐, 和豆瓣/亚马逊/goodreas等推荐网站的搜索. 列出了主要的学习资料和内容, 具体如下: 操作系统主题的相关学习学习材料 深入理解计算机系统 程序员的自我修养 Linux内核解析 现代操作系统 Linux常用命令行总结 实验和项目操作数据库主题 mysql必知必会: 很薄，可以很快读完。*《MySQL性能调优和架构设计》，很薄，可以很快读完。 官方文档中：MySQL Server System Variables，MySQL Server System Status。 通读并测试mysql、mysqldump、mysqladmin命令行工具的参数。《鸟哥的Linux私房菜》 《高性能MySQL（第三版）》，阿里的几个DBA翻译的，非常经典，值得耐心阅读；开发人员可以阅读这一本即可应对大部分问题。《MySQL技术内幕：InnoDB存储引擎（第2版）》，通过这个可以了解到很多Innodb运行的内部原理。 《MySQL技术内幕：SQL编程》。《O’Reilly：高可用MySQL：构建健壮的数据中心》，通过这个可以了解到很多replication的细节。 《Understanding MySQL Internals》，可以为进一步的阅读源码打下基础。 MySQL官方文档，官方文档历来是杀人越货居家必备，解决问题可以第一时间查阅官方文档，得到很权威的解释。 JVM主题学习 JVM重要论文阅读和学习 JVM调优实践 常用JVM的工具命令行掌握和学习一遍 线上问题排查演练 未完待续…………….]]></content>
      <tags>
        <tag>技术</tag>
        <tag>书单</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高效工作的行动清单]]></title>
    <url>%2F2016%2F10%2F07%2Fdeep-work-do-list%2F</url>
    <content type="text"><![CDATA[知行合一 最近在研究如何更加高效与学习的方法, 看了一系列相应的书籍与博客. 但是理论吸收之后, 更重要的是执行, 能将书中思想应用到真正的生活与工作之后, 这才有价值, 否则就等于没有学习. 学习最核心的使命和目标是 带来改变. 下面是根据学习理论和个人实际情况, 制定的行动和操作指南. 理论的东西可以参考我之前的一些博客(见附录). 处理IM与社交网络干扰的方法彻底远离微信这个黑洞微信中有价值的信息实在是太少了, 使用微信中的信息更多的是 耗能型娱乐属性, 既得不到真正的休息, 又浪费时间. 真正重要的关系不会沉淀在 微信 之上. 在微信备注：停用微信, 请联系电话: xxx-xxxxxx 每个星期采用一个小时, 一次处理所有的微信积累信息. 真正有价值和有效果的沟通与联系依次如下: 面对面讨论 &gt; 电话沟通 &gt; 邮件 &gt; IM软件 公司内部的IM进行批量处理大部分在公司内部找你的事情, 都是不重要的事情, 也是不紧急的. 下面列出根据沟通事宜的不同情况, 选择相应的沟通渠道: 重要而紧急的事情: 当面沟通 重要而不紧急的事情: 邮件沟通 or 当面沟通 非重要而紧急的事情: 电话沟通 or 当面沟通 不重要不经济的事情: 拒绝浪费时间 批量处理公司内部IM的沟通联系, 早上11：00和下午3:00 查看一次IM的消息, 一次性处理.在内部IM中,备注 『不在线, 紧急事情请电话联系 xxxxxx 』 处理频繁被打断的方法不受干扰的空间与时间 -『容器隔离』 早上8点半提前到公司, 保证不会受到影响的1.5小时. 早晨是大脑思维活动最高效的时间. 如果非常重要的和高专注度的工作, 寻找公司内部无人的会议室, 封闭处理和写作 周六周日, 抽出半天, 到咖啡馆无人打扰的地方工作和学习 对他人的打断沟通 -『消息队列处理』 公司其他人的粗暴打断say no 对于正在高认知度的工作, 如果他人这时候有打断, 应该这样做 先拒绝 不好意思, 目前这个事情比较紧急, 我之后去找你看下 将他的需要与你沟通的事件push到 待办清单 回归原有线程工作. 直到这个任务全部完成 从待办清单中的根据事件优先级选择下一个处理任务 处理刚刚和你沟通的任务, 将处理的消息 push 到刚刚同你沟通的人 耳机防干扰 - 『防御式编程』 买一个降噪耳机, 当你写代码和写作的时候,戴上,对于不想回应的打断直接回避 处理睡眠和休息的问题明确工作和休息分界线 回家之后不再使用智能手机, 散步与思考. 上下班的路途中, 远离手机碎片信息, 放空电脑, 或者音乐/kindle. 工作40分钟之后, 休息一下: 可以打咖啡或者打水 可以和别人讨论下 不要休息期间看手机, 这样会更累而已 睡眠隔离 闹钟 代替手机闹铃, 将手机远离卧室. 买两个闹钟 : 一个在公司用于时间计时器, 一个在家里让自己刻意离线 -&gt; 当闹钟使用. 确保在床上只有两件事, 睡觉 或者 sex. 处理手机和网络综合症离线阅读和学习 重要文献打印阅读 - 断开网络 重要长的网络文献,可以一键 『send to kindle』发送 到Kindle, 然后在Kindle上进行深度阅读 采用alfred一键断网: http://www.packal.org/workflow/network-connection 手机分离 重要学习、工作任务的时候: 手机强制离线 可以将手机放置在 - 一个手够不着的地方 - 静音 两个手机工作模式 非智能手机A: 用于日常沟通,电话沟通. 智能手机B: 用于日常工作中软件开发, 系统登录(程序员有需要) 阅读学习使用 kindle 和 纸质书籍, 上班的路上不再使用手机 -&gt; kindle电子书 或者 电台/ 音乐放松思考 : 吃饭/上厕所远离手机 处理电子邮件依赖症 采用outlook邮箱 - 最强大的邮箱(个人感觉) 采取过滤邮件 将邮件分类处理, 采用规则 rule 将不重要的遇见自动 read归类, 不要被这些邮件的信息占用大脑 重要邮件, 设置标注(比如你的manager) 一天只分配限制次数处理邮件. 集中批量处理你的邮件 早上不要看邮件, 99%的邮件没必要立即回复, 24小时之内就可以 培养习惯 对于这段时间,重点培养的习惯采用电脑桌面, 提示. 采用习惯坚持的奖励计划. 制定事情的优先级 周日晚上, 抽出30分钟, 离线规划下一周的主要任务 采用 优先级管理 - 四象限的方法来进行任务安排管理工作 每天早上来的第一件事情, 安排你当天的工作计划. 总结我觉得高效工作与深度思考的核心目标: 『以你自己为个人核心』,牢记掌握工作与生活中的主动权. 知道自己的核心目标和主张, 从而安排事情的优先级, 将『被动响应』的打断低效率模式, 改为 『主动发送』的批量处理和高专注度工作模式.专注于那些能真正带来价值的 重要而不紧急的事情. 拒绝80%的 不重要的事情. 但是人的自制力是有限的, 总是会受到莫名的一些干扰, 所以你需要一些有效方法可以帮你. 相关理论参考书籍 Deep Work So Good They Can’t Ignore You 慢思考：大脑超载时代的思考学 相关博客 慢思考 专家路线]]></content>
      <tags>
        <tag>个人管理</tag>
        <tag>清单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息过载时代如何做到深入思考]]></title>
    <url>%2F2016%2F10%2F06%2Fslow-think%2F</url>
    <content type="text"><![CDATA[如果你读过苹果第一代的宣传册，你会发现大标题写着‘简约是复杂的终极形式’。这句话的意思是说，你第一次接触某个问题的时候会觉得它很简单，因为你对它一无所知。等到你真正理解了这个问题，你会想出很多复杂的解决方案，因为它的确错综复杂。大多数人止步于此。但有少数人会继续在午夜里冥思苦想，最终理解问题背后的深层规律，找出简洁优雅的解决方案。但是，能走到这一步的人太过罕见。 — Steve Jobs 互联网和智能手机越来越普及, 为我们的我们的日常生活/学习/工作提供了极大的便利, 获取信息的成本变得极为便宜, 我们的生活中基本已经不能离开了手机, 甚至有人提及了手机是人器官的一个组成部分了. 但是互联网和手机等ICT技术给我们带来了便利的同时, 也带来了一些问题. 我们的信息很多, 但是系统性的知识很少. 浏览很多, 但是高质量的阅读很少. 我们使用微信很多, 但是高质量的对话却很少. 我们的生活中总是被各种在线软件打断, 新一代的e时代青年发现在这个扁平化信息世界中,越来越难以专注于一个问题之中. 我们总是在 一个链接跳转到另外一个链接之中, 一遍又一遍的刷着朋友圈, 渴望一个有一个信息刺激, 但是又无法深入问题之中. 我们究竟是怎么回事? 直到最近几天 读了一本欧洲工商学院教授写书 慢思考-大脑超载时代的思考学. 才对这个问题有了一个深入的理解. 书籍的具体信息可以参考豆瓣链接: 慢思考：大脑超载时代的思考学 在这个扁平的世界里为什么我们反而需要真正的思考?当今世界的工作可以分为两种,高认知工作(脑力工作)与低认知工作(体力工作). 脑力工作者不同于一般的体力工作者,其工作需要非常集中精力与思考, 高认知工作者需要大量的独立和深入思考, 需要大量大脑前额的参与工作. 高认知工作职位比如,学者, 作家, 企业家, 工程师. 艺术家等. 如果希望持久的创造力,进行高水平的认知工作,必须要有持久与专注的工作习惯作为依托.在当今世界，纯粹的“无脑”劳动正在消失。在某种程度上，我们每个人都是脑力劳动者，我们的成功也取决于脑力劳动的质量。 从大脑结构来说, 人的大脑拥有三套负责认知、决策的脑系统，分别是反射脑、思考脑和存储脑。反射脑快而原始，它自发而无意识地处理问题。思考脑慢而成熟，它会消耗大量能量，而且很容易疲劳。还有时刻等待空闲的存储脑，它负责存储信息和激发创意。 所以, 高认知工作更多需要思考脑的参与. 那么如今的这种信息社会会对我们的思考脑工作会什么影响了? 思考脑的特点: 无法并行处理多个工作任务,基本可以看做是 串行处理器 多个任务的切换会造成效率降低 极度消耗能量(血糖), 需要损耗意志力来进行 思考脑的这个结构, 造成了我们的目前ICT技术的使用不当, 会对于我们高质量的思考和工作造成影响. 造成无法深度思考和学习的原因高节奏的城市工作, 团队的工作形式, 异常发达的通信工具, 会对于我们的深度思考造成一系列的问题, 主要表现四个方面: 总是在线 多任务处理 缺乏睡眠 面对持续的低压力困扰 总是在线 在资讯丰富的世界里，信息的充沛意味着其他东西的匮乏：信息会消耗资源，这些资源会随着信息的极大丰富转而成为稀缺物品。我们进一步探寻，信息消耗的是什么资源？答案显而易见：接收者的注意力。 ——赫伯特·西蒙（Herbert Simon，1916—2001），诺贝尔经济学奖得主 为什么总是在线会对我们的思考和工作造成影响? 总是在线将会给我们带来直接的冲击就是 过量的信息冲击, 不论信息是否重要, 我们都要面对. 导致了我们信息接收很多, 思考很少, 知识很少. 另外, 过多的碎片信息会占用了我们过多的大脑空间, 让我们无法腾出『内存空间』给我们思考使用. 同时, 面对这些过量信息, 我们大脑一直要处理决策, 而对于这些过量信息的处理决策,会不断消耗大脑能量,造成大脑疲劳. 多任务并行效率低下之前提到的思考脑的本质,无法处理多任务并行处理. 不论是 多任务的并行的情况, 还是在多任务频繁的切换情况下，均会导致我们的思考低下, 出现问题. 睡眠不足睡眠不足会导致大脑思考能力迅速下降. 睡眠期间是富有创意的存储脑的黄金时段。是要维持最佳的思考能力，充足的睡眠真的不可或缺. 现代人由于越来越多的贪恋收集信息, 导致不断的人为拖延入睡时间. 持续的低水平压力适当的压力会激发人的动力和潜力,从而有更加优异的表现. 若是它们长期处于较高的水平，就会损伤我们的身体，带来慢性高血压、肌肉紧张、心率过快、高凝血水平等问题，还会抑制免疫系统。持续的低水平压力,会造成身体一直处于紧绷状态. 间歇性的压力才是健康的压力。间隔期应该足够长、足够频繁，好让体内的压力激素逐渐消退，让身体得到放松. 为什么我们难以离线? 从根本上说，脸书用户的动机有三种：（1）窥视他人生活；（2）为自己创造一个有特色的身份；（3）满足内心的自恋倾向。” 不断检查社交媒体比检查邮箱更糟糕，因为它会带来额外的问题：社交媒体会催生“身份焦虑”，让你感觉更加孤独、悲惨。而所谓的“身份焦虑”，基本上就是“嫉妒”的学术委婉说法。考虑到人人都只会发布生活中有趣、正面的东西，你会感觉自己的生活不如别人的丰富，所以你对生活的满意度会下降。千真万确，你越沉迷于脸书，那么你在现实中的真实朋友就越少，与人相处的时间也越少，而且你会越发相信，谁都比你过得幸福。如果你能在不同的情况下见到大量真人，你就会以更加真实的角度看待他们的生活。所以你会一直寻找下去，形成恶性循环：你越频繁地查看脸书，就越无法满足，感觉越不快乐、越孤独；于是你就更需要小小的兴奋感，因此你更加频繁地检查脸书，变得更加不快乐…… 我们该如何在扁平化的信息社会中深度思考?面对上面的一系列问题, 提出了四种有效的方法来解决上门的四种问题: 彻底离线 批量处理 恢复正常的睡眠模式 正确面对压力 方法一: 彻底离线解决总是在线的最重要的办法是彻底离线——抽出固定的不受打扰的时间，来完成专注的工作和对话。具体你可以这样做: - 首先，请找出一天中你的思考脑表现最好的时间段 - 第二个收效极大的方案是，在周日的晚上抽出20分钟彻底离线，用于计划一周的工作，确定最重要的任务是哪些，安排在什么时间去做，并确保每一天都有充足的安静时间。 - 每天请抽出10分钟来安排第二天的事情，时间不应晚于睡前一小时。 - 长按四秒钟，它就会进入保护大脑模式， - 是阅读艰深的文本，请把它打印出来，在老式的纸张上阅读，而且要彻底离线。 方法二: 批量处理合理安排任务的基本原则非常简单：尽一切可能减少切换次数。如何减少切换次数, 我们可以使用批量处理方法. 一次集中处理一个主题的任务序列, 减少大脑上下文的切换工作.同时选择批量处理的任务,得首先安排任务的优先级, 可以采用 艾森豪威尔原理 和 帕累托定理进行任务优先级安排. 具体表现: 艾森豪威尔原理 通过四象限制定自己的时间优先级, 重点处理 重要不紧急的事情, 每天通过这种事情执行 帕累托定理 20%的投入带来80%的效果 累积帕累托定理, 持续的帕累托定理 引入系统化的批量处理*，要大幅提高智力生产力，这是最重要的方法，尤其是在非常规性的工作中 * 一次完成一个任务，或者相对完整的一部分，拒绝所有干扰 * 把密切相关的任务划分到同一批次 * 把不相关的任务、邮件和琐事丢到一个批次里 * 准备好在家里处理的批次 * 每次批量处理结束后，好好休息一下 方法三: 恢复正常的睡眠模式面对睡眠不足,那么我们唯一的方法就是 恢复我们祖先一直采用的 正常的睡眠模式 - 『该睡的时候就去睡』.杜绝因为手机电子产品,导致的故意延迟晚上的入睡时间.对于我们如何更好睡眠,可以采取一些方法: 设定两个就寝闹钟 你应该设定1号就寝闹钟，提醒你至少提前1小时（最好提前1.5～2小时）彻底离线，而2号闹钟则设在睡前1小时，好提醒你开始睡前流程。 每天在同样的时间就寝、起床，包括周末。 如果你需要在周末补觉，请提前一会儿上床，而不是晚起，这样对睡眠模式和生物钟的干扰更小 为了恢复健康睡眠，你应该保证自己的床只用于睡觉和性行为。 最好不要用手机当闹钟，也不要把手机放在床边，甚至根本别把它拿进卧室。 睡前喝一杯 “喝杯热牛奶” 请勿在睡前6～8小时内摄入任何刺激性饮料 白天尽量多动动。如果疲劳的只有你的大脑 睡前2～3小时内请勿锻炼，让身体有时间代谢 在床边放一个笔记本，记下所有好主意和可能有的忧虑。买一支带LED灯的笔，以免吵醒你的伴侣。 如果晚上保证正常的睡眠, 白天是不需要小睡和打盹的. 小睡切勿超过20分钟. 如果不想小睡就不用小睡. 方法四: 正确面对压力持续处于低压力状态不是好的状态,现在的学术名次叫这个为 亚健康状态. 对耐压能力有重大影响的基本态度包括：是否将挑战看作成长发展的机会，遇到重大事件时的基本感觉，对工作和家庭角色的投入程度，是否拥有明确的优先级和清晰、现实的目标。 正确的做法:拒绝香烟，注意体重，健康饮食，保持良好的睡眠，不依赖兴奋剂、咖啡因或镇静剂，对工作满意，保持良好的幽默感，懂得并实践优秀的放松技巧，控制酒精摄入，注意计划截止日期。 总结高认知工作,需要在于持久的/专注的/无干扰模式下的思考, 我们通过 专注单一任务,保持充足睡眠, 远离在线干扰, 达到一种禅的境界吧. 该吃饭的时候吃饭, 该睡觉的时候睡觉, 改工作到时候工作 思维导图 书摘关于大脑与深度思考 人的大脑拥有三套负责认知、决策的脑系统，分别是反射脑、思考脑和存储脑。反射脑快而原始，它自发而无意识地处理问题。思考脑慢而成熟，它会消耗大量能量，而且很容易疲劳。还有时刻等待空闲的存储脑，它负责存储信息和激发创意。 史蒂夫·乔布斯在评价Mac电脑时说：“等你真正理解了这个问题，你会想出很多复杂的解决方案，因为它确实错综复杂。大多数人止步于此。但有少数人会继续在午夜里冥思苦想，最终理解问题背后的深层规律，找出简洁优雅的方案。 做的事情并不在于多，而在于把一件事做到极致，而在追求极致的过程中享受这种愉悦感。 第一，彻底离线——抽出固定的不受打扰的时间，来完成专注的工作和对话。 史蒂芬·金也为我们做了很好的榜样。记得在《写作这回事：创作生涯回忆录》一书中，他这样形容自己的工作：“我的日程安排得很清晰——上午用来处理新事务，比如撰写文章；下午用来打盹和写信；晚上用来读书、和家人一起玩，做些紧急修改。基本上，上午是我最重要的写作时间。”关起门来不受打扰地写作，一天 4个小时或许比史蒂芬·金的描述更让你感到惊讶，但无人可以否定他的成就，他是我们这个时代最成功、最高产的作家。 在当今世界，纯粹的“无脑”劳动正在消失。在某种程度上，我们每个人都是脑力劳动者，我们的成功也取决于脑力劳动的质量。 如果有人要求你去做某件事，你应该思考一下这件事需要花费你多少时间，然后订下规则：永远不要直接把任务放进“待办”列表，而应该立即检查日志，找出什么时候有时间，然后把这个任务填进去。如果暂时没有整块的时间，你应该拒绝这个任务，或者协调一下，推迟一些不重要的任务，或者将它交给别人去做。零敲碎打的工作方式不但会降低你的效率，而且很可能无法达成让各方满意的结果，受害最深的也是你自己。（更多解决方案请见本书第三部分。） 关于睡眠与休息 对脑力劳动者来说，休息并不是浪费时间，而是为下一个任务补充能量、打磨斧头（想一想存储脑的工作机制吧） 习惯的形成让我们变得更快、更高效，于是思考脑可以腾出来考虑别的事情、学习新的习惯。一般而言，我们每天在无意识状态下做出的行为和决策有好几百件。如果没有这些习惯，我们的大脑必将不堪重负，无法正常工作。所以我们每一个人都由一大堆习惯组成，我们是刻板印象的造物，时时刻刻总在重复和复制过去的自己。 定时放空大脑，什么也不想，什么都不做，对保持智力生产力和创意来说，这样的放松至关重要。因此，很多人眼中“浪费的时间”反而是存储脑的“工作时间”。在工作坊里，他曾提出“西氏3B创意时刻”：小憩（break）、洗澡（bath）和睡眠（bed）。 睡眠期间是富有创意的存储脑的黄金时段。听起来或许太疯狂，但是要维持最佳的思考能力，充足的睡眠真的不可或缺！ 托马斯·弗里德曼（Thomas L.Frledman）将互联互通、无所不在的现代社会描述为“扁平世界”。复杂的世界也考验着思考脑的极限，它必须整理、归纳时时刻刻都在增加的大量信息。 关于深度阅读/深度对话/深度思考 VS 碎片阅读/ 如果带着一颗“碎片化的扁平脑子”，任由一维（扁平）的反射脑束缚（扁平化）思考脑，放任外界干扰持续不断地切割你的注意力，你就无法在这个复杂的“扁平世界”里很好地发展。 深入阅读是思考不可或缺的前提. 深入细致的阅读是思考过程中非常重要的一部分。安静、从容、不受打扰地阅读一本书、一篇文章或一份备忘录，这样的精读与我们在电脑或手机屏幕上浮光掠影地浏览完全就不是一回事 但精读和这样的浏览完全不同。互联网上不同的观点之间没有明确的联系，很少引发深入、广泛、具有前瞻性的思考。 “真正的对话”是谈话的第三个层面，从这里开始，谈话中会牵涉到感情，无论是你的还是别人的。在真正的对话中，你们会综合彼此看法，创造出新的意义，并由此建立更稳固的关系。能够发起并引导真正的对话，这是智商和情商的重要元素 “真正的对话”是谈话的第三个层面，从这里开始，谈话中会牵涉到感情，无论是你的还是别人的。在真正的对话中，你们会综合彼此看法，创造出新的意义，并由此建立更稳固的关系。能够发起并引导真正的对话，这是智商和情商的重要元素. 只有通过真正的对话，你才能深入地认识、理解一个人和他的想法。 有四种因素会让生活中的“普通”场景充满危险。这四种因素分别是：随时在线、多任务并行、负面压力和睡眠不足。 快思考是一种原始、被动的方式，过于简单，流于表面。快速对话是不可能完成的任务，“快”和“对话”本身就是一对不可调和的矛盾。 锁链一: 随时在线 在资讯丰富的世界里，信息的充沛意味着其他东西的匮乏：信息会消耗资源，这些资源会随着信息的极大丰富转而成为稀缺物品。我们进一步探寻，信息消耗的是什么资源？答案显而易见：接收者的注意力。 ——赫伯特·西蒙（Herbert Simon，1916*01），诺贝尔经济学奖得主 碎片信息通过活跃的反射脑源源不断地涌入，挤占了思考脑的空间。一旦思考脑被抑制，你就很难进行深入、广泛、超前的思考。 而若是你任由自己陷入被动应激模式，时时刻刻紧盯着电子邮件和屏幕，那就完全不可能做出像样的准备 锁链二: 并行处理 但如果并行的只有2个项目，那么产出的确有所增加，这可能是因为当一个项目变得很无聊或是暂时卡壳的时候，转而处理另一个项目的确能带来收益。但若是任务数量达到3个以上，表现就急剧下降。 锁链三: 低水平压力 随时在线还会削弱你的恢复能力，如果你分不清工作和生活的界限，情况就更加糟糕。 若是它们长期处于较高的水平，就会损伤我们的身体，带来慢性高血压、肌肉紧张、心率过快、高凝血水平等问题，还会抑制免疫系统。 间歇性的压力才是健康的压力。间隔期应该足够长、足够频繁，好让体内的压力激素逐渐消退，让身体得到放松 要预防、治愈这些小毛病，办法只有一个——定期离开屏幕！ 最后我们再来谈谈眯眼。你应该彻底避免眯眼看东西，因为它会增加眼睛承受的压力。 锁链四: 缺乏睡眠 电脑屏幕发射的蓝光甚至比正午的太阳还多。因此，近距离紧盯平面显示器、平板电脑或智能手机会抑制褪黑素的分泌，影响你的生物钟。 为什么我们难以离线 其中50%～95%的邮件是完全无关的（荒野上的草丛），但是当然，他们不想错过任何一封来自老板或客户的有用邮件（异动的树枝） 关闭提醒新邮件、新消息的一切声音和图标。 互动交流能增加幸福感，孤立、消费性的网络活动却会增强孤独感，降低归属感和幸福感。 从根本上说，脸书用户的动机有三种：（1）窥视他人生活；（2）为自己创造一个有特色的身份；（3）满足内心的自恋倾向。” 不断检查社交媒体比检查邮箱更糟糕，因为它会带来额外的问题：社交媒体会催生“身份焦虑”，让你感觉更加孤独、悲惨。而所谓的“身份焦虑”，基本上就是“嫉妒”的学术委婉说法。考虑到人人都只会发布生活中有趣、正面的东西，你会感觉自己的生活不如别人的丰富，所以你对生活的满意度会下降。千真万确，你越沉迷于脸书，那么你在现实中的真实朋友就越少，与人相处的时间也越少，而且你会越发相信，谁都比你过得幸福。如果你能在不同的情况下见到大量真人，你就会以更加真实的角度看待他们的生活。所以你会一直寻找下去，形成恶性循环：你越频繁地查看脸书，就越无法满足，感觉越不快乐、越孤独；于是你就更需要小小的兴奋感，因此你更加频繁地检查脸书，变得更加不快乐…… 屈从于消费性的现代通信技术，这无法增加你的产出，只会摧毁你的智力表现。一旦你明白了这一点，那么你的智力表现和生产力就有可能得到提高。 解锁方法一: 彻底离线 最重要的办法是彻底离线——抽出固定的不受打扰的时间，来完成专注的工作和对话。 每天只检查两次邮箱，手机永远留在车里，而且定期躲到附近的办公室享受一段不受打扰的时光 热衷于多任务并行的人都无法正确认识这一点：离开他们，世界依然如常运转。 离线的具体方法 首先，请找出一天中你的思考脑表现最好的时间段 第二个收效极大的方案是，在周日的晚上抽出20分钟彻底离线，用于计划一周的工作，确定最重要的任务是哪些，安排在什么时间去做，并确保每一天都有充足的安静时间。 每天请抽出10分钟来安排第二天的事情，时间不应晚于睡前一小时。 长按四秒钟，它就会进入保护大脑模式， 是阅读艰深的文本，请把它打印出来，在老式的纸张上阅读，而且要彻底离线。 解锁方法二: 批量处理 合理安排任务的基本原则非常简单：尽一切可能减少切换次数。 接下来要决定在什么时间做什么事情。有意识地根据重要程度筛选所有干扰，结果你会少做很多不重要的事情，工作效率也会大幅提高。 引入系统化的批量处理，要大幅提高智力生产力，这是最重要的方法，尤其是在非常规性的工作中 （1）一次完成一个任务，或者相对完整的一部分，拒绝所有干扰 （2）把密切相关的任务划分到同一批次 （3）把不相关的任务、邮件和琐事丢到一个批次里 （4）准备好在家里处理的批次 （6）每次批量处理结束后，好好休息一下 如何面对邮箱难题 ①关掉收件箱的所有提醒，无论是图标还是声音 ②别把收件箱当成待办事项表。 ③别让任何可能浪费时间的东西进入你的收件箱。 （6）不要每封邮件都回 解锁方法三: 恢复正常的睡眠模式 设定两个就寝闹钟 你应该设定1号就寝闹钟，提醒你至少提前1小时（最好提前1.5～2小时）彻底离线，而2号闹钟则设在睡前1小时，好提醒你开始睡前流程。 每天在同样的时间就寝、起床，包括周末。 如果你需要在周末补觉，请提前一会儿上床，而不是晚起，这样对睡眠模式和生物钟的干扰更小 为了恢复健康睡眠，你应该保证自己的床只用于睡觉和性行为。 最好不要用手机当闹钟，也不要把手机放在床边，甚至根本别把它拿进卧室。 睡前喝一杯 “喝杯热牛奶” 请勿在睡前6～8小时内摄入任何刺激性饮料 白天尽量多动动。如果疲劳的只有你的大脑 睡前2～3小时内请勿锻炼，让身体有时间代谢 在床边放一个笔记本，记下所有好主意和可能有的忧虑。买一支带LED灯的笔，以免吵醒你的伴侣。 如果晚上保证正常的睡眠, 白天是不需要小睡和打盹的. 小睡切勿超过20分钟. 如果不想小睡就不用小睡. 解锁方法四: 正确面对压力 对耐压能力有重大影响的基本态度包括：是否将挑战看作成长发展的机会，遇到重大事件时的基本感觉，对工作和家庭角色的投入程度，是否拥有明确的优先级和清晰、现实的目标。 古罗马人早就知道这一点——“mens sana in corpore sano”，意思是说“健全的精神寓于健全的身体” 正确的做法: 拒绝香烟，注意体重，健康饮食，保持良好的睡眠，不依赖兴奋剂、咖啡因或镇静剂，对工作满意，保持良好的幽默感，懂得并实践优秀的放松技巧，控制酒精摄入，注意计划截止日期。 因为间歇性的压力才是健康的压力，所以你应该培养或恢复定期休息的习惯，恢复身体和精神能量。 要解决随时在线、多任务并行、缺乏休息和低水平压力，每个人的情况都不相同，难易程度也因人而异。 解锁方法五: 培养正确的习惯 “ABC分析”是最简单的，而且非常有效。这三个字母分别代表前因（Antecedent）、行为（Behavior）、后果（Consequence），有时候这三部分也被称为“诱因（Trigger）、行为/习惯（Behavior/Habit）、奖励（Reward）”。 这些方法也可以帮助你改掉其他束缚大脑的习惯。如果你有睡眠问题，那么你的卧室应该只用于睡觉（和性爱），其他事情统统都不在卧室里做，当然包括工作。 如果你想改变某个行为的后果或奖励，那么可能应该使用强大的普雷马克原理。 定义: 如果某个低频/不太愿意做的行为后面总是紧跟着一个高频想做的行为，那么前一个行为出现的概率也会升高。 千万不要低估“提醒”的效果。每次我建议人们善用提醒，大家总是觉得这个法子很傻 或者设一个新的屏保图案，隐晦地传达信号：“你真的没有更好的事可做了？ 任何计划要取得成功，90%取决于落实和跟进。]]></content>
      <tags>
        <tag>工作方法</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀到不能被忽略]]></title>
    <url>%2F2016%2F10%2F04%2Fbe-so-good%2F</url>
    <content type="text"><![CDATA[十一期间, 利用空闲时间又重新看了一遍 Be So Good That they can not ignore you. 这是上半年看完 英文版之后, 国内中文翻译之后直接看的中文版. 这本书基本可以秒杀市场上一切国内的心灵鸡汤类的职场建议书籍, 作者是麻省理工大学的计算机博士毕业, 使用了非常严谨的学术训练的方法去分析该如何规划自己的职业发展路径. 『follow your heart』 不管用作者开门见山的提出了一个否定的观点: 追随自己的激情是一个非常坏的建议, 市场上那些所谓的『follow your heart』, 追随自己的内心去选择自己的职业 都是一厢情愿,并不适用. 作者称这一类的想法为 职业选择的 『激情模型』. 大部分所谓的兴趣爱好根本都不是真正称的上是职业的. 那么激情模型被否定之后, 我们该怎样判定和看待我们的职业了? 工匠思维首先, 作者去调研了怎样的工作满意度才是最高. 作者发现工作的满意度其实和工作的种类是关系不大的, 而更多的是和工作的熟练程度, 那些工作时间越长, 对于工作越能胜任的人满意度越高. 所以作者提出了一种 『工匠思维』模型, 来看待职业发展. 工匠思维 关注自己能给世界带来什么，而激情思维则关注世界能给自己带来什么。大多数人是用后一种思维方式来对待自己的职业生涯。 而与之相反的激情思维, 则是总是考虑工作能给我带来什么, 让人去“追随自己的激情”不仅是盲目的乐观主义，还可能是一份让人饱受困惑、忧虑之苦的职业的开始。 紧接着, 作者调研总结了, 对于满意工作的几个指标: 自主权 胜任 归属 职场资本那么如何才能才能获取这些满意工作的属性, 作者认为这些东西完全是靠自己工作中积累和争取的, 为此作者提出了一个 『职场资本(careere capital)』. 高质量的工作是稀缺产品, 如果希望获得 高自主权/ 胜任/ 具有 归属感的工作, 需要拿同样的稀缺的 『职场资本』 进行交换. 经济学基本理论告诉我们，如果你想获得某些既稀缺又宝贵的东西，就需要提供同样稀缺而宝贵的东西作为交换，这就是经济学上最基础的供给与需求理论（Supply and Demand） 没人欠你一份好工作，你要自己去努力争取，而且这个过程不会一帆风顺。 那么接下来就清晰了, 如果我们想获取一种好的工作, 我们就需要培养自己的 『职场资本』, 关键还在于 培养自己 稀缺 愿意人们付钱的 有市场价值的 职业资本. 如何不断提升自己的职业资本? 作者使用了『异类』的观点 - 一万小时定理 刻意练习 也就是希望通过 刻意的, 有反馈的, 不断需要动脑筋的 思考和工作, 来不断提升自己的技能. 让自己通过长时间的有意义的训练和积累, 从而达到专家的水平. 而专家的技能是市场上非常稀缺的和有价值的, 从而个人可以通过专家的技能来换取更满意和高质量的工作. 这里的技能, 可能是 编程, 市场销售, 设计, 创业的等不同的技能栈. 关键是，要强迫自己去完成工作、强迫技能形成。这是最难的阶段. 刻意练习的策略这些稀缺的技能注定是很难获取的并且很辛苦获取的, 许多人都因此而放弃. 作者认为能让自己持续的进行『刻意练习』和 突破 『技能效应』必须要有一定的方法和策略, 为此作者给出了几个方法: 目标管理 时间统计 自底向上的思考(第一性原理) 其中, 我对于作者提到了斯坦福能源投资人的案例非常深刻, 其中提到了 通过 每周的时间花费统计来强制自己保证真正的时间投入到真正的事业之中: 统计反馈: 用一张表格来追踪自己每一天、每个时刻的活动，详细到以15分钟为单位。他想确保自己的精力都花在了重要的活动上 限制无用 每天只给自己分配了90分钟用于处理邮件。 自底向上的思考深度的思考, 作者提出了费曼经常提到的一个观点: 费曼有一个强迫性的习惯, 将重要的论文和数学概念进行不断的拆解, 直到自己可以自底向上地理解其中的概念. 总结这本书涉及的点很多, 作者为这本书看了很多文献和样例的调查. 其实核心观点就是: 手艺人的思维, 通过不断的刻意练习, 不断逃离自己的舒适区, 不断提升自己的专业技能. 让自己的专业技能 在市场上稀缺而宝贵, 有买家愿意 用高价值的工作来进行替换. 最后, 当你对你的工作抱怨吐槽的时候, 记住这句话: Be So Good That They Can Not Ignore You]]></content>
      <tags>
        <tag>工匠思维, 职场</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Github-2016年开源项目]]></title>
    <url>%2F2016%2F09%2F21%2Fgithub-star%2F</url>
    <content type="text"><![CDATA[Github 开源项目关注Github公布了2016年的开源项目观察, 具体的报告地址:https://octoverse.github.com. 有兴趣的可以进入原网址阅读, 有一些比较有意思的项目. 受到关注的开源项目整理几个最火的并且有可能和自己相关的开源项目: tensorflow - 谷歌开源的深度学习框架. react-native - facebook开源的全栈的客户端开发 docker - 容器 vscode - 微软出的新一代的代码编辑工具, 目前和sublime比,还有一定的差距,观察中 kubernetes https://github.com/kubernetes/kubernetes - 容器的自动化部署与管理工具 netdata -&gt; 对于Linux系统的实时监控, 界面做到非常酷炫. 对于基本运维的同学应该有用. 开发语言的选择另外就是Github统计了所有三百多中语言的排名,最火的语言是 JavaScript, 然后依次是 Java, Python. 另外一个就是Go语言增长非常快. 从统计来看, 基本上 使用JavaScript 和 Java技术栈, 就可以搭建一套完整的互联网应用.从 客户端(android/ios), web, 服务端, 数据应用. 所以从Github的应用趋势来看, 一个高要求的后端程序员应该具备的开发语言技术栈如下: 精通 Java, 深入JVM实践和配置, 了解Java实现的底层原理. 精通 JavaScript, node/react-native 系列, 可以使用JavaScript技术栈,搭建 web 和 移动的应用. 熟悉 python脚本语言编写, 可以用来做一些网络爬虫, 文本处理的代码量较少的脚本编写. 熟练使用 shell, Linux的管理和运维必备 会使用Groovy &amp; grails. JVM上的Ruby 和 Rails,用Java的方法尝试敏捷开发应该学习一下这套框架. 一些感受容器化与微服务Docker 和 Kubernetes 的结合, 完成容器的一体化部署与集成. 整个基础运维将会加快向 容器和微服务方面推进. JavaScript的快速发展随着node, react-native等一系列JavaScript 框架的出现, 使用JavaScript就可以实现前后端语言的统一. 但是因为JavaScript语言本身的一些缺点, JavaScript作为后端语言的线上生产实践和开发效率还有待验证和提高. 越来越多的公司参与到开源建设2016年参与最多开源项目的公司竟然是 Microsoft, 这样一个之前强烈反对开源的公司, 在一两年之内做出如此大的转变. 其实是体现了软件和互联网行业的一个变化, 就是开源运动越来越强烈, 各大公司都希望利用开源平台来吸引更多的开发者进入到自己的生态系统.]]></content>
      <tags>
        <tag>github, 编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-鸟哥私房菜学习note]]></title>
    <url>%2F2016%2F09%2F19%2Flinux-bird-study-note-md%2F</url>
    <content type="text"><![CDATA[重新学习基础Linux的相关操作. 所谓的位指的是CPU一次数据读取的最大量. 64位, 代表CPU一次可以读取64bits这么多数据. 所谓多核,就是一个实体CPU外壳中,含有两个以及以上的CPU单元, 多个计算核心 CPU的几个不同点: 1) CPU具有不同的指令集 2) CPU的频率 超线程(hyper-threading, HT)1) 在每一个CPU内部, 将重要的寄存器分成两群, 而让程序分别使用这俩群寄存器. 个人电脑的内存主要元件为动态随机存取内存. 通常越大的内存代表越快速的系统,这是因为系统不用常常释放一些内存内部数据. 第二层高速缓存, 整合到了CPU内部, 无需总是再进行内存数据读取的功能. BIOS(basic input output system)写死到主板上面的一个内存芯片之中, 没电的时候可以保存数据, 只读存储器, ROM.9 硬件的接口传输协议1）SATA接口2) SAS接口3) USB接口 10 固态硬盘(SSD) solid state disk没有磁盘了,不需要马达转动, 通过内存直接读取, 没有数据延迟,而且 还很省电.1) hdd 和 ssd 搭配使用, ssd作为系统盘, 数据存储在 hdd上面. 11 文字编码系统常用的英文编码表为 ASCII系统, 每个符号占用1Bytes, 8位,所以有256个不同变化.中文采用big5. 目前国际上统一采用标准字符集, utf8 操作系统操作系统也是一组程序, 程序的重点在于管理电脑所有的活动, 以及驱动系统中的硬件.操作系统会提供一整组的开发接口给工程师来开发软件! 工程师只要遵守改开发接口就很容易进行开发了. 核心, 提供了对于硬件的管理 系统调用层: 提供了管理核心的开发接口操作系统其实就是 核心 与其 提供的 接口工具.核心需要提供的功能: 系统调用接口 程序管理(Process Control): 多CPU的任务分配 内存管理 文件系统管理 设备驱动 Thompson的文件系统的特点:1) 所谓程序和系统都是文件属性2）所有程序的目的都是为了实现 高效率实现最终目标 GNU发展中非常重要的几个软件:1）Emacs2) GNU C3) GNU C Library4) Bash Shell distribution = “Kernel + Softwares + Tools + 可安装程序” distributions主要分为两大系统,一种是使用RPM方式安装软件的系统,包括 Red Hat, Fedora, SuSE等都是这类; 一种则是使用Debian的dpkg方式安装软件的系统,包 括Debian, Ubuntu, B2D等等 Linux 的文件权限与目录配置1）文件身份: owner/group/others2) 权限: read/write/execute3) root的相关信息在 /etc/passwd. 个人密码 /etc/shadow. 团体的信息在 /etc/group下面 17 权限解读1drwxrwxr-x 2 huleihit huleihit 4096 Aug 23 11:06 .pip/ 第一栏:drwxrwxr-x [d] 代表这是一个文件夹 9个字符,分别代表 文件拥有者的权限, 文件所属群组的权限, others权限第二栏: 2 代表有多少文件链接到 此节点之中第三栏: huleihit 代表这个文件的拥有者账号第四栏: huleihit 代表这个文件的所属群组第五栏:4096 代表 文件的大小为 4096bytes, 4k大小第六栏: Aug 23 11:06 代表 文件最近修改的时间第七栏： .pip/ 代表文件名称 注意: 如果对于文件夹没有执行x权限，则不可以进入该文件夹，即使有r权限,也不行 18 修改文件属性的命令:chgrp 修改文件所属群组chown 改变文件所有者chmod 改变文件的权限 重点在于chmod的使用, 文件各权限的分数对照表如下:r 4分， w 2分, x 1分, 然后使用分数进行修改 , 奇葩的linux权限设计, fuck 文件与文件夹的权限 1) 权限对于文件的意义r (read):可读取此一文件的实际内容,如读取文本文件的文字内容等;w (write):可以编辑、新增或者是修改该文件的内容(但不含删除该文件);x (eXecute):该文件具有可以被系统执行的权限。 2) 权限对于目录的重要性r (read contents in directory):表示具有读取目录结构清单的权限,所以当你具有读取(r)一个目录的权限时,表示你 可以查询该目录下的文件名数据。 所以你就可以利用 ls 这个指令将该目录的内容列表显 示出来!w (modify contents of directory):这个可写入的权限对目录来说,是很了不起的! 因为他表示你具有异动该目录结构清单 的权限,也就是下面这些权限:创建新的文件与目录;删除已经存在的文件与目录(不论该文件的权限为何!) 将已存在的文件或目录进行更名;x 仅仅是可以 确定使用者能否进入这个目录 对一般文件来说,rwx 主要是针对“文件的内容”来设计权限, 对目录来说,rwx则是针对“目录内的文件名列表”来设计权限。 文件种类与扩展名的作用 文件 纯文本文件(ASCII) 二进制文档 数据格式文件 目录 链接文件 设备与设备文件（与系统周边与存储等相关的一些文件), 通常都集中在 /dev文件下面 区块文件(主要就是一些存储数据)提供系统随机存取的周边设备 字符设备文件 数据接口文件(sockets): 主要用于网络上的数据承载功能 数据输送档(FIFO)：FIFO是一种特殊的文件类型 通常常用的linux扩展名 .sh : 脚本或批处理文件 (scripts),因为批处理文件为使用shell写成的,所以扩展名 就编成 .sh ; Z, .tar, .tar.gz, .zip, *.tgz: 经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的,由于不同的压缩软件,而取其相关的扩展名 ! .html, .php:网页相关文件,分别代表 HTML 语法与 PHP 语法的网页文件 ! .html 的 文件可使用网页浏览器来直接打开,至于 .php 的文件, 则可以通过 client 端的浏览器来 server 端浏览,以得到运算后的网页结果呢! Linux的文件配置依据: FHS(File Hierachy Standard) 标准出炉了 FHS的重点在于规范每个特定的目录下应该要 放置什么样子的数据而已。 这样做好处非常多,因为Linux操作系统就能够在既有的面貌下 (目录架构不变)发展出开发者想要的独特风格 一般的规范如下: 事实上,FHS针对目录树架构仅定义出三层目录下面应该放置什么数据而已,分别是下面这 三个目录的定义: / (root, 根目录):与开机系统有关; /usr (unix software resource):与软件安装/执行有关; /var (variable):与系统运行过程有关。 关于具体的FHS可以参考维基百科的部分内容: https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard /usr(unix software resouce)目录的意义/usr里面放置的数据属于可分享的与不可变动的(shareable, static), 如果你知道如何通过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务 器),那么/usr确实可以分享给区域网络内的其他主机来使用喔! /var 的意义如果/usr是安装时会占用较大硬盘容量的目录,那么/var就是在系统运行后才会渐渐占用硬盘 容量的目录。 因为/var目录主要针对常态性变动的文件,包括高速缓存(cache)、登录文件 (log file)以及某些软件运行所产生的文件, 包括程序文件(lock file, run file),或者例如 MySQL数据库的文件等等。 linux目录树 文件管理 绝对路径与相对路径 绝对路径:由根目录(/)开始写起的文件名或目录名称, 例如 /home/dmtsai/.bashrc; 相对路径:相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/ 等 等。反正开头不是 / 就属于相对路径的写法 PS, 可以使用 uname -a 查看相应linux的版本, 具体的信息可以通过man uname 查看 工作目录的概念 常用的目录文件表示:123.. 代表上一层目录- 代表**前一个工作目录**~ 代表“目前使用者所在的主目录 关于可执行文件的变量: $PATH cp 执行相应的链接请求不同点: cp -l 和 cp -s的区别:使用 -l 及 -s 都会创建所谓的链接文件(link file),但是这两种链接文件却 有不一样的情况。这是怎么一回事啊? 那个 -l 就是所谓的实体链接(hard link),至于 -s 则 是符号链接(symbolic link), 简单来说,bashrc_slink 是一个“捷径”,这个捷径会链接到 bashrc去!所以你会看到文件名右侧会有个指向(-&gt;)的符号! 其他一些常用的命令:1) basename: 获取最后的文件名2) dirname 获取路径的文件夹名 21 查看文件内容的主要命令1） cat 进行全文2) nl 显示行号进行输出3) tac 从最后一行开始显示4) tail 从尾部开始进行显示5) less 更加强大的查询功能，基本提供了less之后,就不需要其他的一些功能了6) head 和 tail 相对应，从头开始查阅文件内容7) umask 就是构建默认的文件的权限8) lsattr 隐藏文件的功能,具体使用 man 进行查询,有这个记忆就可以了9) file 查看文件类型 22 Linux下的三个主要时间modification time (mtime): 当该文件的“内容数据”变更时,就会更新这个时间!内 容数据指的是文件的内容,而不是文件的属性或权限喔!status time (ctime): 当该文件的“状态 (status)”改变时,就会更新这个时间,举 例来说,像是权限与属性被更改了,都会更新这个时间啊。access time (atime): 当“该文件的内容被取用”时,就会更新这个读取时间 (access)。举例来说,我们使用 cat 去读取 /etc/man_db.conf , 就会更新该文件的 atime 了。 23 SUID 的概念1) Unix系统如何确定一个进程对于资源的访问权限?UNIX的内核是根据什么来确定一个进程对资源的访问权限的呢？是这个进程的运行用户的（有效）ID，包括user id和group id。用户可以用id命令来查到自己的或其他用户的user id和group id。 如何理解 suid 和 sgid? 因为 Unix系统如何决定对于进程的访问处理关系?通常是根据 进程的有效用户ID, suid可以让执行该资源的时候,将实际有效用户ID使用该文件的所有者，而不是 实际进程的用户ID 文件搜索如何处理? which 来搜索可执行文件的地址, which 命令查找 path 下面所有的命令的 locate 来进行文件的位置定位，效率比find 效率更高(The locate program searches a database for all pathnames which match the specified pattern.) Linux磁盘管理 Linux磁盘与文件系统管理1) Linux的主要的实体磁盘和虚拟磁盘 /dev/sd[a-p][1-128]:为实体磁盘的磁盘文件名 /dev/vd[a-d][1-128]:为虚拟磁盘的磁盘文件名 数据存取方式有两种方式: 索引式文件系统(indexed allocation): 通过inode 和 block两个模块进行索引和管理block数据 FAT 格式(U盘的文件组织方式): inode常用来存储文件的相关属性, block 用来存储文件相关的内容, 数据内容 文件系统EXT2 与 FileSystem不同的文件系统组成EXT2的整体文件系统架构图: 1) inode 用来记录文件的属性, 以及文件实际放在那里, 就是实际指向的block的地方inode的文件结构的说明: https://en.wikipedia.org/wiki/Inode_pointer_structure 2)superblock(超级区块)主要记录fileSystem相关的整体信息: block与inode总量 未使用与已使用的inode/block的数量 filesystem的挂载时间, dumpe2fs 查询 Ext家族 superblock信息指令 dumpe2fs - dump ext2/ext3/ext4 filesystem information blkid 通过这个指令调出目前 所有被格式化的设备，展现出来, 开始显现 挂载的意义挂载 : 将文件系统与目录树结合的动作我们称为“挂载”。 挂载点一定是目录,该目录为进入该文件系统的入口。 24 查看磁盘空间的命令 df 查看各个磁盘的空间, df -h 以一种显性的方式查看相应的磁盘空间情况 du 估计与查看各个文件的大小 25 hard link 与 symbolic link1) hard link 通过 创建一个新的文件名, 指向同一个inode2) symbolic link 通过 指向另个一文件名, 而不是 inode. swap(内存交换空)swap使用到的时候,其实就是 实体内存不足的情况下发生了. 27 tar linux下面的打包 命令 tar -cf 创建一个压缩文件名称 tar -xf 解压缩一个文件, 基本命令够用就可以了 28 bash的几个优点如下: 命令编修能力 (history) 命令与文件补全功能 命令别名设置功能 工作控制、前景背景控制 (其实,也是后台执行的功能提供) 程序化脚本 29.shell指令太长,就是用 \ 命令进行跳脱, 进行新的一栏的开发 linux变量的获取 echo ${变量名}1) echo ${变量名} 就可以获取相应的变量的信息2) 等号两边不能直接接空白字符,如下所示为错误: “myname = VBird”或“myname=VBird Tsai”3) 该变量为扩增变量内容时,则可用 “$变量名称” 或 ${变量} 累加内容,4）若该变量需要在其他子程序执行,则需要以 export 来使变量变成环境变量: “export PATH’ 关于export的变量的使用什么是“子程序”呢?就是说,在我目前这个 shell 的情况下,去启用另一个新的 shell ,新的那 个 shell 就是子程序啦. 通过 export 操作就可以 继承之前的 相应环境下的变量了. read 可以用来读取 输入的环境变量 read [-pt] variable 32 别名设置工具 alias 与 unalias使用的方法: alias ll=&apos;ls -l&apos; # 赋予相应的快捷支付方式名称 unlias ll # 移除相应的快捷方式 33 history 调用出历史使用命令 hisotry n 调用出相应的历史命令 (n行以内的历史命令) !n 代表执行第 number 行的命令 34 指令执行的顺序 以相对/绝对路径执行指令,例如“/bin/ls”或“./ls”; 由alias找到该指令来执行; 由bash内置的(builtin)指令来执行; 通过$PATH这个变量的顺序搜寻到的第一个指令来执行。 35 默认配置1) login shell 其实只会读取这两个配置文件: /etc/profile:这是系统整体的设置,你最好不要修改这个文件; ~/.bash_profile或~/.bash_login或~/.profile:属于使用者个人设置,你要改自己的数 36 重定向 与 垃圾黑洞1）/dev/null 垃圾桶黑洞设备与特殊写法2) 相应命令行的管道处理关于管道的 2&gt;$1http://blog.sina.com.cn/s/blog_5842daa30101enz5.html 字符匹配处理工具 grep的使用 [] 来选择 集合字符的问题 对于一些不重要的章节, 快速突破学习, 换别的方面进行学习 shell scripts脚本的功能1) 必须具备r 和 x的功能才能执行2) 可以通过 绝对路径 / 相对路径 / 变量PATH 三种路径的方法来学习3) $ 代表的是小指令 的东西 类似于shell的编程 和 命令, 当需要用的时候,再去查找, 应该更快一些 用户权限管理1) 用户识别码 UID 与 GID的不同每个文件都有两个ID 用户 ID 群组 ID what a fuck! no talking! no saying 2) /etc/passwd 下面的具体的用户权限的形式如下: huleihit:x:1000:1000:Ubuntu:/home/huleihit:/bin/bash huleihit 代表相应的群组x 是密码1000 是 UID 用户id1000 是 GID 群组 id 关于shell的类型说明与介绍:http://blog.shengbin.me/posts/shell-types 关于登录时候,自动选择shell的类型 123456789101112# if running bashif [ -n &quot;$BASH_VERSION&quot; ]; then # include .bashrc if it exists if [ -f &quot;$HOME/.bashrc&quot; ]; then . &quot;$HOME/.bashrc&quot; fifi# set PATH so it includes user&apos;s private bin if it existsif [ -d &quot;$HOME/bin&quot; ] ; then PATH=&quot;$HOME/bin:$PATH&quot;fi 如果存在bash-version，则启动.bashrc的bash相关配置. 同时可以将被动bin加入了path之中. 可以直接使用命令进行操作 关于创建新的用户 useradd几个重要的文件夹:/etc/passwd 所有用户的信息/etc/shadow 相关用户的密码/etc/group 相关群组的信息 如何在 ubuntu上创建 和 删除新的用户 创建用户1) 使用sudo 用户登录2) 然后输入命令: sudo useradd daniel3) 然后根据linux输出的信息依次填入 用户密码, 重复确认就可以了 给创建的用户添加root权限通过usermod -aG sudo daniel 删除用户如果删除用户, 可以使用 sudo userdel -f daniel, 其中 -f 的命令是 force 强制 相关的链接: https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-ubuntu-quickstart ACL(access control list)1) 访问控制权限 - linux系统的访问控制权限2) 访问权限控制 - 相关重要的网址链接: http://www.tldp.org/ 鸟哥推荐的技术书籍: http://linux.vbird.org/linux_basic/0120howtolinux/ 0120howtolinux_1.php 电脑基础知识 http://www.study-area.org/compu/compu.htm 网络基础知识: http://www.study-area.org/network/network.htm]]></content>
  </entry>
  <entry>
    <title><![CDATA[influxData技术栈学习]]></title>
    <url>%2F2016%2F09%2F19%2FTICK-tech-stack-md%2F</url>
    <content type="text"><![CDATA[InfluxData公司提供了一个TICK技术栈,类似于Elastic公司的ELK 技术栈一样, 都是基于开源软件, 提供了一整套的数据处理功能. 不过 Elastic公司的ELK技术栈, 更多的是面向日志处理系统, 实时的日志流分析而言, Logstash提供日志收集, ElasticSearch提供日志存储和检索,Kibana提供数据的可视化展现.而Influxdb则提供了面向时间序列的数据的高性能解决方案. 提供了一个 TICK 栈, 具体的产品包括: InfluxData的各系统关系 T - TelegrafTelegraf 是一个收集指标和数据的client,然后写入 InfluxDB. 相当于ELK栈中的 logstash 功能. I - InfluxDBInfluxDB 是一个开源的GO语言为基础的数据库, 用来处理时间序列数据,提供了较高的可用性. C - ChronografChrongraf 是一个web程序, 用来展现InfluxDB的数据层. 相当于 ELK中的 Kibana. K - KapacitorKapacitor 是一个处理时间序列数据的处理引擎. 可以设置不同的规则进行监控和报警. 从上面的介绍可以知道, TICK中的核心是 influxDB,时间序列数据库. 下面将具体介绍influxDB的相关知识. InfluxDB 命令行操作使用命令行操作 InfluxDB 同 Mysql的命令非常相似 创建数据库CREATE DATABASE mydb 查询数据库show databases 使用数据库use mydb influxdata深入使用influxdata 是一个使用 GO 语言编写的 开源的时间序列数据库. 一般可以用来 记录metrics, 事件, 和 相应的性能分析. 主要的特点: 通过 HTTP API来进行操作. 所以不需要任何的服务端代码就可以进行 使用和运行 数据可以标记(tag), 提供比较灵活的查询 类似SQL语句的类型的查询 简易安装, 快速的获取数据和写入数据 用来解决时间序列的查询解答, 数据点 可以在 非常快速的100ms 以内被检索和查询 安装在ubuntu的机器上安装, 可以使用以下的linux命令进行相应的操作 123curl -sL https://repos.influxdata.com/influxdb.key | sudo apt-key add -source /etc/lsb-releaseecho &quot;deb https://repos.influxdata.com/$&#123;DISTRIB_ID,,&#125; $&#123;DISTRIB_CODENAME&#125; stable&quot; | sudo tee /etc/apt/sources.list.d/influxdb.list 启动启动命令:1sudo service influxdb start 创建数据库curl -G &apos;http://localhost:8086/query&apos; --data-urlencode &quot;q=CREATE DATABASE mydb&quot; 参考文档 https://github.com/influxdata/influxdb]]></content>
  </entry>
  <entry>
    <title><![CDATA[在公有云Azure上构建ElasticSearch集群]]></title>
    <url>%2F2016%2F08%2F17%2FBuild-es-on-Azure%2F</url>
    <content type="text"><![CDATA[最近在公司的项目中,使用到了ES的集群进行一些订单的索引和统计, 但是项目中是维护之前别人的项目,所以就在此文中利用自己的MSDN账号, 在微软的公有云Azure上完全构建一个ES集群进行索引和查询. Azure是微软推出的一个公有云服务, 用户可以在Azure上构建自己的IT服务,类似于 亚马逊的AWS和国内的阿里云, 具体可以参考链接: https://azure.microsoft.com/zh-cn/ 登录Azure申请资源申请虚拟网络 vpn构建一个相应的虚拟网络,这样虚拟网络内的机器就可以相互通信,构建ES的集群. 申请虚拟机选择ubuntu的虚拟机实例, 然后注意在选择网络的时候,选择我们上一步构建的虚拟网络. 然后创建成功.因为我们需要构建ES的集群,所以我们需要3台虚拟机, 依次创建另外两台虚拟机. 安装ElasticSearch软件安装JavaAzure上的Linux虚拟机中默认是不安装 Java的，所以我们需要自己安装Java. ElasticSearch支持jdk1.8. 则我们下载进行安装: 123 sudo add-apt-repository ppa:webupd8team/javasudo apt-get update sudo apt-get install oracle-java8-installer 验证安装是否成功:1234huleihit@es-node02:~$ java -versionjava version &quot;1.8.0_101&quot;Java(TM) SE Runtime Environment (build 1.8.0_101-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode) 安装elasticsearch下载elasticsearch软件包:1curl -L -O https://download.elastic.co/elasticsearch/release/org/elasticsearch/distribution/tar/elasticsearch/2.3.5/elasticsearch-2.3.5.tar.gz 解压: gunzip elasticsearch-2.3.5.tar.gztar -xf elasticsearch-2.3.5.tar 修改ES的集群配进入elasticsearch的解压缩文件,修改相应的配置文件 config/elasticsearch.yml 主要的修改点如下: 12345cluster.name: es-cluster #集群名称node.name: es-node01 #节点名称network.host: ip discovery.zen.ping.multicast.enabled: falsediscovery.zen.ping.unicast.hosts：[&quot;10.0.0.4&quot;,&quot;10.0.0.5&quot;,&quot;10.0.0.6&quot;] 启动es配置好之后,我们就要启动每台机器上的ES了 ./elasticsearch-2.3.5/bin/elasticsearch -d 通过 -d 代表我们希望让elasticsearch在后台运行. 然后我们看是否启动成功: lsof -i :9200 出现 123COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAMEjava 4657 huleihit 91u IPv6 32751 0t0 TCP ip6-localhost:9200 (LISTEN)java 4657 huleihit 92u IPv6 32752 0t0 TCP localhost:9200 (LISTEN) 则代表进程已经启动, 然后我们curl一下: curl 127.0.0.1:9200 则会返回: 123456789101112&#123; &quot;name&quot; : &quot;es-node02&quot;, &quot;cluster_name&quot; : &quot;es-cluster&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;2.3.5&quot;, &quot;build_hash&quot; : &quot;90f439ff60a3c0f497f91663701e64ccd01edbb4&quot;, &quot;build_timestamp&quot; : &quot;2016-07-27T10:36:52Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;5.5.0&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 总结在Azure上安装 elasticsearch的关键其实就是需要构建一个虚拟网络,这样让所有的实例都在一个网络环境内, 可以相互连接, 剩下的就是配置 集群中其他节点的ip地址,安装官网配置就可以了.]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome神器 - Vimium]]></title>
    <url>%2F2016%2F08%2F11%2FVimium%2F</url>
    <content type="text"><![CDATA[一直在控制自己不要使用鼠标, 希望让自己的双手永远不要远离键盘, 这样让自己的大脑完全处于 一种专注和心流的无干扰模式. 真正的将自己的计算资源专注于 逻辑的思考, 让整个的外部操作(工具.写作.写码) 都可以跟上自己思维的流动,这时候, 你所有的外部工具已经和自己的身体连为一体了. 通过一个简单的统计软件,发现目前自己日常工作中的前4个软件如下: Sublime 常用的笔记整理和脚本编辑工具 chrome 网页浏览工具 Intellij IDEA 公司Java开发软件平台 Iterm2 shell平台 其中, 除了 Chrome 浏览器之外, 其他三个都配备强大的快捷键操作, 基本上可以不需要任何鼠标进行全部的操作功能, Chrome 之前也一直没有找到合适的工具,自身提供的快捷键操作也非常有限. 知道有一天发现了一个Chrome的快捷键插件 - Vimium. 从此, 操作Chrom获取外部信息的效率提升了一个指数级. 关于 Vimium 的相关介绍:Github的地址: https://github.com/philc/vimium. 截止到 2016年8月11日, 已经有了5272的关注,可以发现这个插件是极度受欢迎的 几个比较重要的快捷键如下: ? 会弹出相应的说明文档, 类似于 wiki中一样. 可以通过帮助栏快速学习和掌握相应的其他快捷键.具体的弹出快捷键如下: j 页面向上滑动 k 页面向下滑动 h 页面向左边滑动 l 页面向右边滑动 gg 到达页面的顶部 G 到达页面的底部 shift + j 选择左边的页面 shift + k 选择右边的界面 T 进行历史网页的搜索 (真是非常的强大啊) -&gt; 不断强化和优化你的开发工具 f 发现当前网页中的链接，出现的字幕选择，当前页面跳转 F 发现当前网页中的链接，出现的字幕选择，打开一个新的页面进行显示 b 打开相应的的书签的查找窗口 yy 复制当前网页的链接到剪贴板 gi 到页面中的第一个Input, 然后tab 进行不用tab的切换 其他的快捷键操作,可以继续去Github上的WIKI继续了解, 上面的几个快捷键已经足够支持你日常Chrom的80%的操作了.将这些快捷键执行操作,反复上下执行10次, 在你的大脑神经元连接中深深的构建一个连接, 以后就让chrome的操作快捷键vim模式成为你的默认执行方式, 这样可以大大的节省你的开发时间.]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Junit 5 用户手册]]></title>
    <url>%2F2016%2F08%2F10%2FJunit5-document%2F</url>
    <content type="text"><![CDATA[Junit 是Java中使用最多的第三方库, 在Java测试体系中占据了极为重要的位置. 目前JUnit 5 已经发版,以下是官方用户使用手册的中文翻译, 以供参考. 1. 概述本文档是为了提供全面的 参考手册, 程序员编写测试用例，插件作者，引擎作者，同样提供 工具和IDE的开发者. 1.1 Junit5 有什么特点不像之前的Junit的版本, Junit5 是有由来自3个不同的子项目组合起来的. Junit5 = JUnit Platform + JUnit Jupiter + JUnit Vintage Junit Platform Junit平台在JVM的平台上提供了 基础的测试框架. 它同样提供了 TestEngine的API接口,以用于 在平台上开发测试框架. 更重要的是，这个Junit平台提供了一个命令行应用程序和在maven以及Gradle商家编程插件, 来进行单元测试 JUnit Jupiter 是一个 Junit5 新的单元测试编程模型. Jupiter 子项目提供了 TestEngine 以用于运行 Juniter. Junit Vintage 提供了一个 运行 Junit3 和 Junit4 的TestEngine的平台. 1.2 支持的Java版本Junit5 在运行时需要依赖Java8. 但是, 你依然可以测试通过之前JDK版本号编译的代码. 2 安装对于final release 和 milestones版本的构件(Artifacts)都部署到了Maven Central.Snapshot的构建部署到了 Sonatype的 仓库,路径在 /org/junit. 2.1. Dependency Metadata2.1.1. JUnit PlatformGroup ID: org.junit.platformVersion: 1.0.0-M2 Artifact IDs:junit-platform-commonsjunit-platform-consolejunit-platform-enginejunit-platform-gradle-pluginjunit-platform-launcherjunit-platform-runnerjunit-platform-surefire-provider 2.1.2. JUnit JupiterGroup ID: org.junit.jupiterVersion: 5.0.0-M2Artifact IDs:junit-jupiter-apijunit-jupiter-engine 2.1.3. JUnit VintageGroup ID: org.junit.vintageVersion: 4.12.0-M2Artifact ID: junit-vintage-engine 2.2. JUnit Jupiter Sample ProjectsJunit5-samples 项目代码仓库托管了一系列的 基于 Junit Jupiter 和 Junit Vintage 示例项目. 你将会在一下的项目中发现 相对应的 build.gradle 和 pom.xml文件: 对于Gradle项目, 检查 junit5-gradle-consumer 项目 对于Maven项目, 检查 junit5-maven-consumer 项目 3 编写测试用例第一个测试用例 123456789101112import static org.junit.jupiter.api.Assertions.assertEquals;import org.junit.jupiter.api.Test;class FirstJUnit5Tests &#123; @Test void myFirstTest() &#123; assertEquals(2, 1 + 1); &#125;&#125; 3.1 注解Junit Jupiter 支持以下的注解用于测试配置 和 拓展 框架 所有核心的注解都位于 junit-jupiter-api 模块的 org.junit.jupiter.api的包下面. 注解名称 描述 @Test 声明这个方法为测试方法 @TestFactory 声明这个方法是针对于dynamic tests测试工厂 @DisplayName 给这个类或者方法设定一个特殊的名字 @BeforeEach 声明这个方法将在每一个测试方法之前进行执行,类似于 Junit4中的 @Before @AfterEach 声明这个方法将在每一个测试方法之后进行执行,类似于 Junit4中的 @After @BeforeAll 声明这个方法将在所有的测试方法之前进行执行, 类似于 Junit4 中的 @BeforeClass, 所有被注解的方法都必须是静态的和可继承的 @AfterAll 声明这个方法将在所有的测试方法之后进行执行, 类似于 Junit4 中的 @AfterClass, 所有被注解的方法都必须是静态的和可继承的 @Nested 声明这个方法是 一个嵌套的, 非静态的方法, 由于Java语言的限制, @BeforeAll 和 @AfterAll 方法都不能被用在 @Nested注解的方法上 @Tag 被用于通过声明 标签来过滤测试方法, 既不是在方法级别也不是在类的级别上. 相当于 Junit 4中的 测试组 @Disabled 用于声明一个测试方法或者测试类失效, 相当于 Junit 4 中的 @Ignore @ExtendWith 被用于使用在 用户定制的扩展组件上 3.1.1 元注解 和 组合注解Junit Jupiter 注解可以被用于元注解. 这意味着, 你可以定义自己的定制的注解, 定制的注解就可以从 元注解进行继承. 举个例子, 与其不断的通过代码复制和粘贴 @Tag(&quot;fast&quot;) , 你可以创建如下定制化的组合注解 @Fast. @Fast可以被用于 替代 @Tag(&quot;fast&quot;). 123456789101112import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.junit.jupiter.api.Tag;@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)@Retention(RetentionPolicy.RUNTIME)@Tag("fast")public @interface Fast &#123;&#125; 3.2 标准的测试类一个标准的单元测试 12345678910111213141516171819202122232425262728293031323334353637383940414243import static org.junit.jupiter.api.Assertions.fail;import org.junit.jupiter.api.AfterAll;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeAll;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;class StandardTests &#123; @BeforeAll static void initAll() &#123; &#125; @BeforeEach void init() &#123; &#125; @Test void succeedingTest() &#123; &#125; @Test void failingTest() &#123; fail("a failing test"); &#125; @Test @Disabled("for demonstration purposes") void skippedTest() &#123; // not executed &#125; @AfterEach void tearDown() &#123; &#125; @AfterAll static void tearDownAll() &#123; &#125;&#125; 任何测试类和测试方法都必须是 public 3.3 展示名称(DisplayName)测试类和测试方法都可以声明定制的特殊的名称, 通过 空间/特殊的字符, 甚至是emojis表情. 定制的名称将被用于在展示测试任务和测试报告之中. 12345678910111213141516171819202122import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Test;@DisplayName("A special test case")class DisplayNameDemo &#123; @Test @DisplayName("Custom test name containing spaces") void testWithDisplayNameContainingSpaces() &#123; &#125; @Test @DisplayName("╯°□°）╯") void testWithDisplayNameContainingSpecialCharacters() &#123; &#125; @Test @DisplayName("😱") void testWithDisplayNameContainingEmoji() &#123; &#125;&#125; 3.4 断言(Assertions)Junit Jupiter 继承了 许多 Junit 4中的断言方法, 同时增加了 一些适配 Java 8 lambdas特点的方法. 所有的 Junit Jupiter 都是静态方法, 在 org.junit.jupiter.Assertions类中. 123456789101112131415161718192021222324252627282930313233343536import static org.junit.jupiter.api.Assertions.assertAll;import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.junit.jupiter.api.Assertions.expectThrows;import org.junit.jupiter.api.Test;class AssertionsDemo &#123; @Test void standardAssertions() &#123; assertEquals(2, 2); assertEquals(4, 4, "The optional assertion message is now the last parameter."); assertTrue(2 == 2, () -&gt; "Assertion messages can be lazily evaluated -- " + "to avoid constructing complex messages unnecessarily."); &#125; @Test void groupedAssertions() &#123; // In a grouped assertion all assertions are executed, and any // failures will be reported together. assertAll("address", () -&gt; assertEquals("John", address.getFirstName()), () -&gt; assertEquals("User", address.getLastName()) ); &#125; @Test void exceptionTesting() &#123; Throwable exception = expectThrows(IllegalArgumentException.class, () -&gt; &#123; throw new IllegalArgumentException("a message"); &#125;); assertEquals("a message", exception.getMessage()); &#125;&#125; 3.5 假定(Assumptions)Junit Jupiter 继承了Junit 4中 一部分假定方法, 同时提供了 部分借用Java 8 lambdas的特性. 所有的 Junit Jupiter assumptions都是静态的方法,在 org.junit.jupiter.Assumptions类中进行定义. 12345678910111213141516171819202122232425262728293031323334import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assumptions.assumeTrue;import static org.junit.jupiter.api.Assumptions.assumingThat;import org.junit.jupiter.api.Test;public class AssumptionsDemo &#123; @Test void testOnlyOnCiServer() &#123; assumeTrue("CI".equals(System.getenv("ENV"))); // remainder of test &#125; @Test void testOnlyOnDeveloperWorkstation() &#123; assumeTrue("DEV".equals(System.getenv("ENV")), () -&gt; "Aborting test: not on developer workstation"); // remainder of test &#125; @Test void testInAllEnvironments() &#123; assumingThat("CI".equals(System.getenv("ENV")), () -&gt; &#123; // perform these assertions only on the CI server assertEquals(2, 2); &#125;); // perform these assertions in all environments assertEquals("a string", "a string"); &#125;&#125; 3.6 禁用测试(Disabling Tests)以下是一个禁用测试的测试单元. 123456789import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;@Disabledclass DisabledClassDemo &#123; @Test void testWillBeSkipped() &#123; &#125;&#125; 同样, 这里也可以禁用单个测试方法 1234567891011121314import org.junit.jupiter.api.Disabled;import org.junit.jupiter.api.Test;class DisabledTestsDemo &#123; @Disabled @Test void testWillBeSkipped() &#123; &#125; @Test void testWillBeExecuted() &#123; &#125;&#125; 3.7 标签和过滤(Tagging and Filtering)测试类和方法可以被打上标签. 这些标签可以被之后用来过滤 test discovery and execution 12345678910111213import org.junit.jupiter.api.Tag;import org.junit.jupiter.api.Test;@Tag("fast")@Tag("model")class TaggingDemo &#123; @Test @Tag("taxes") void testingTaxCalculation() &#123; &#125;&#125; 3.8 嵌套测试(Nested Tests)嵌套测试给我们的测试者提供 表达不同测试组之间关系的功能. 以下是一个定制的例子: 嵌套测试单元以用来测试一个堆栈123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertFalse;import static org.junit.jupiter.api.Assertions.assertThrows;import static org.junit.jupiter.api.Assertions.assertTrue;import java.util.EmptyStackException;import java.util.Stack;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Nested;import org.junit.jupiter.api.Test;@DisplayName("A stack")class TestingAStackDemo &#123; Stack&lt;Object&gt; stack; @Test @DisplayName("is instantiated with new Stack()") void isInstantiatedWithNew() &#123; new Stack&lt;&gt;(); &#125; @Nested @DisplayName("when new") class WhenNew &#123; @BeforeEach void createNewStack() &#123; stack = new Stack&lt;&gt;(); &#125; @Test @DisplayName("is empty") void isEmpty() &#123; assertTrue(stack.isEmpty()); &#125; @Test @DisplayName("throws EmptyStackException when popped") void throwsExceptionWhenPopped() &#123; assertThrows(EmptyStackException.class, () -&gt; stack.pop()); &#125; @Test @DisplayName("throws EmptyStackException when peeked") void throwsExceptionWhenPeeked() &#123; assertThrows(EmptyStackException.class, () -&gt; stack.peek()); &#125; @Nested @DisplayName("after pushing an element") class AfterPushing &#123; String anElement = "an element"; @BeforeEach void pushAnElement() &#123; stack.push(anElement); &#125; @Test @DisplayName("it is no longer empty") void isEmpty() &#123; assertFalse(stack.isEmpty()); &#125; @Test @DisplayName("returns the element when popped and is empty") void returnElementWhenPopped() &#123; assertEquals(anElement, stack.pop()); assertTrue(stack.isEmpty()); &#125; @Test @DisplayName("returns the element when peeked but remains not empty") void returnElementWhenPeeked() &#123; assertEquals(anElement, stack.peek()); assertFalse(stack.isEmpty()); &#125; &#125; &#125;&#125; 只有非静态的嵌套类(如:内部类) 可以被标记为 @Nested 测试. 嵌套可以是任意的深度, 并且这些内部类可以被认为是测试类中全部的组成部分, 除了一个例外: @BeforeAll 和 @AfterAll 不起作用, 因为 Java 并不允许 static 成员在内部勒类中. 3.9 对于构造函数和方法的依赖注入在之前所有的 Junit版本中, 测试构造函数或者方法并不允许有参数(至少在标准的测试应用中). 作为Junit Jupiter的一个主要变化, 测试构造函数和方法现在都被允许拥有参数. 这就提高了测试的灵活性, 同时构造函数和方法的依赖注入. ParameterResolver定义了在运行期间动态的解析参数值的API接口. 如果一个测试单元的构造函数或者 一个 @Test, @TestFactory, @BeforeEach, @AfterEach, @BeforeAll, 和 @AfterAll 注解的方法接受了一个参数, 这个参数必须在 运行的时候通过一个注册的 ParameterResolver 进行解析.这里有两个内置的自动注册的解析器:TestInfoParameterResolver: 如果一个方法参数 是一种 TestInfo类型, 则TestInfoParameterResolver 将会自动的 获取一个 TestInfo 实例获取值. 这个 TestInfo可以被用于 获取一个测试的 展示名称, 测试的类, 测试的方法 或者对应的标签tags. 展示名称要么是一个技术名称, 比如 测试类的或者测试方法的名字, 要么是一个 通过 @DisplayName 定制化的名称. TestInfo 作为一个替换 Junit 4 中 TestName的方法. 以下是具体的使用例子: 123456789101112131415161718192021222324252627282930 import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.DisplayName;import org.junit.jupiter.api.Tag;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.TestInfo;class TestInfoDemo &#123; @BeforeEach void init(TestInfo testInfo) &#123; String displayName = testInfo.getDisplayName(); assertTrue(displayName.equals("TEST 1") || displayName.equals("test2()")); &#125; @Test @DisplayName("TEST 1") @Tag("my tag") void test1(TestInfo testInfo) &#123; assertEquals("TEST 1", testInfo.getDisplayName()); assertTrue(testInfo.getTags().contains("my tag")); &#125; @Test void test2() &#123; &#125;&#125; TestReporterParameterResolver: 如果一个方法的参数 是一个 TestReport 类型, 这个 TestReporterParameterResolver 将会 获取一个 TestReport实例. 这个 TestReport将会被用于输出目前测试运行中的数据. 这些数据将被可以用于 TestExecutionListener.reportingEntryPublished() 同时将会被IDEs使用, 或者被包含在测试报告中. 在Junit Jupiter 中, 你应该使用 TestReport 来打印Junit 4的stdout和stderr. 通过使用 @RunWith(JUnitPlatform.class)将会将所有的报告都进入到 stdout. 12345678910111213141516171819202122import java.util.HashMap;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.TestReporter;class TestReporterDemo &#123; @Test void reportSingleValue(TestReporter testReporter) &#123; testReporter.publishEntry("a key", "a value"); &#125; @Test void reportSeveralValues(TestReporter testReporter) &#123; HashMap&lt;String, String&gt; values = new HashMap&lt;&gt;(); values.put("user name", "dk38"); values.put("award year", "1974"); testReporter.publishEntry(values); &#125;&#125; 其他的参数解析器可以通过 使用 @ExtendWith注解来进行扩展开发. 检出的 MockitoExtension类, 比如 一个定制的 ParameterResolver解析器, 同时还没有完全达到生产环境的标准, 它演示了 扩展模型和参数解析流程的 简洁性和直观性. MyMockitoTest显示了如何注入一个Mockito 到 @BeforeEach and @Test 方法中. 123456789101112131415161718192021222324import static org.junit.jupiter.api.Assertions.assertEquals;import static org.mockito.Mockito.when;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.mockito.Mock;import com.example.Person;import com.example.mockito.MockitoExtension;@ExtendWith(MockitoExtension.class)class MyMockitoTest &#123; @BeforeEach void init(@Mock Person person) &#123; when(person.getName()).thenReturn("Dilbert"); &#125; @Test void simpleTestWithInjectedMock(@Mock Person person) &#123; assertEquals("Dilbert", person.getName()); &#125;&#125; 3.10 接口默认的方法(Interface Default Methods)Junit Jupiter 允许 @Test, @TestFactory, @BeforeEach, 和 @AfterEach 成为接口默认的方法. 一个可能的使用场景就是 这样我们就可以为接口协议写测试方法了. 举个例子, 你可以为如何 实现Object.equals和Comparable.compareTo 制定标准,从而编写测试,具体如下: 12345 public interface Testable&lt;T&gt; &#123; T createValue();&#125; 12345678910111213141516171819202122232425public interface EqualsContract&lt;T&gt; extends Testable&lt;T&gt; &#123; T createNotEqualValue(); @Test default void valueEqualsItself() &#123; T value = createValue(); assertEquals(value, value); &#125; @Test default void valueDoesNotEqualNull() &#123; T value = createValue(); assertFalse(value.equals(null)); &#125; @Test default void valueDoesNotEqualDifferentValue() &#123; T value = createValue(); T differentValue = createNotEqualValue(); assertNotEquals(value, differentValue); assertNotEquals(differentValue, value); &#125;&#125; 12345678910111213141516171819202122232425public interface ComparableContract&lt;T extends Comparable&lt;T&gt;&gt; extends Testable&lt;T&gt; &#123; T createSmallerValue(); @Test default void returnsZeroWhenComparedToItself() &#123; T value = createValue(); assertEquals(0, value.compareTo(value)); &#125; @Test default void returnsPositiveNumberComparedToSmallerValue() &#123; T value = createValue(); T smallerValue = createSmallerValue(); assertTrue(value.compareTo(smallerValue) &gt; 0); &#125; @Test default void returnsNegativeNumberComparedToSmallerValue() &#123; T value = createValue(); T smallerValue = createSmallerValue(); assertTrue(smallerValue.compareTo(value) &lt; 0); &#125;&#125; 在你的测试类中, 你可以实现contract接口, 这样就相应的继承了相应的测试单元. 当然你必须实现这些抽象的方法. 123456789101112131415161718class StringTests implements ComparableContract&lt;String&gt;, EqualsContract&lt;String&gt; &#123; @Override public String createValue() &#123; return "foo"; &#125; @Override public String createSmallerValue() &#123; return "bar"; // 'b' &lt; 'f' in "foo" &#125; @Override public String createNotEqualValue() &#123; return "baz"; &#125;&#125; 上面这些测试仅仅是样例,因此没有完全写完. 3.11 动态测试(Dynamic Tests)在JUnit Jupiter中标准的 @Test 注解和Junit 4中的 @Test注解非常的相似. 同样都是为了描述 这是测试单元的方法. 这些测试类在编译期间定义, 因此他们无法再运行期间改变. Assumptions提供了一种动态行为的基本模式, 但是被限制与他们的表达形式 除了 一些测试程序中完全新的测试类型在 JUnit Jupiter 中被介绍. 还有一种新的动态测试方法被介绍, 可以通过 @TestFactory 注解的工厂方法在运行时产生. 和 @Test 方法相反, 一个 @TestFactory方法 并不是测试本身, 而是一个测试单元的工厂. 这样, 一个动态的测试方法就是这个工厂的产品了. 技术上讲, @TestFactry 方法必须返回 Stream, Collection, Iterable 或者 DynamicTest 实例. 这些 动态测试实例将会被懒加载, 确保动态和不确定的测试实例产生. 相比于@Test方法, @TestFactory 方法不能使 private 或者 static. 并且可以选择性的通过 ParameterResolvers 来解析参数. DynamicTest 是运行时生成的测试. 它由 展示名称(display name) 和 Executable组成. Executable 是一个 @FunctionalInterface的实现,这意味着 这些动态测试的实现可以通过 lambda expressions 或者 方法引用. 动态测试的生命周期 JUnit Jupiter 5.0.0-M2版本, 动态测试一定需要通过工厂方法创造出来; 然而, 这可以通过在之后的版本中通过注册机制实现. 3.11.1. 动态测试例子以下的 DynamicTestsDemo 的例子展示了测试工厂和动态测试的不同的几个例子. 第一个方法返回了一个不合法的类型. 因为不合法的返回类型无法再编译器期间发现,在运行时就会抛出 JUnitException 异常. 接下来的五个方法是非常简单的例子, 用来说明 产生 Collection, Iterable, Iterator, or Stream of DynamicTest 实例. 大多数的例子并没有 展示出动态的行为而仅仅是展示了支持的合法的返回类型. 然而, dynamicTestsFromStream() 和 dynamicTestsFromIntStream() 展示了对于给定的Strings 或者 输入的一定范围的数字,是非常容易生成测试的. 最后一个方法是完全的动态生成. generateRandomNumberOfTests()方法实现了 生成随机数, 生成展示名称, 和 测试执行器 的接口, 并且将这三者都提供给了 DynamicTest.stream()方法.尽管generateRandomNumberOfTests()的行为是不明确的,要非常小心的使用并且在重复测试中会产生冲突, 但是它依然体现了 动态测试的强大功能. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import static org.junit.jupiter.api.Assertions.assertEquals;import static org.junit.jupiter.api.Assertions.assertTrue;import static org.junit.jupiter.api.DynamicTest.dynamicTest;import java.util.Arrays;import java.util.Collection;import java.util.Iterator;import java.util.List;import java.util.Random;import java.util.function.Consumer;import java.util.function.Function;import java.util.stream.IntStream;import java.util.stream.Stream;import org.junit.jupiter.api.DynamicTest;import org.junit.jupiter.api.Tag;import org.junit.jupiter.api.TestFactory;class DynamicTestsDemo &#123; // This will result in a JUnitException! @TestFactory List&lt;String&gt; dynamicTestsWithInvalidReturnType() &#123; return Arrays.asList("Hello"); &#125; @TestFactory Collection&lt;DynamicTest&gt; dynamicTestsFromCollection() &#123; return Arrays.asList( dynamicTest("1st dynamic test", () -&gt; assertTrue(true)), dynamicTest("2nd dynamic test", () -&gt; assertEquals(4, 2 * 2)) ); &#125; @TestFactory Iterable&lt;DynamicTest&gt; dynamicTestsFromIterable() &#123; return Arrays.asList( dynamicTest("3rd dynamic test", () -&gt; assertTrue(true)), dynamicTest("4th dynamic test", () -&gt; assertEquals(4, 2 * 2)) ); &#125; @TestFactory Iterator&lt;DynamicTest&gt; dynamicTestsFromIterator() &#123; return Arrays.asList( dynamicTest("5th dynamic test", () -&gt; assertTrue(true)), dynamicTest("6th dynamic test", () -&gt; assertEquals(4, 2 * 2)) ).iterator(); &#125; @TestFactory Stream&lt;DynamicTest&gt; dynamicTestsFromStream() &#123; return Stream.of("A", "B", "C").map( str -&gt; dynamicTest("test" + str, () -&gt; &#123; /* ... */ &#125;)); &#125; @TestFactory Stream&lt;DynamicTest&gt; dynamicTestsFromIntStream() &#123; // Generates tests for the first 10 even integers. return IntStream.iterate(0, n -&gt; n + 2).limit(10).mapToObj( n -&gt; dynamicTest("test" + n, () -&gt; assertTrue(n % 2 == 0))); &#125; @TestFactory Stream&lt;DynamicTest&gt; generateRandomNumberOfTests() &#123; // Generates random positive integers between 0 and 100 until // a number evenly divisible by 7 is encountered. Iterator&lt;Integer&gt; inputGenerator = new Iterator&lt;Integer&gt;() &#123; Random random = new Random(); int current; @Override public boolean hasNext() &#123; current = random.nextInt(100); return current % 7 != 0; &#125; @Override public Integer next() &#123; return current; &#125; &#125;; // Generates display names like: input:5, input:37, input:85, etc. Function&lt;Integer, String&gt; displayNameGenerator = (input) -&gt; "input:" + input; // Executes tests based on the current input value. Consumer&lt;Integer&gt; testExecutor = (input) -&gt; assertTrue(input % 7 != 0); // Returns a stream of dynamic tests. return DynamicTest.stream(inputGenerator, displayNameGenerator, testExecutor); &#125;&#125;]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程, junit5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么多线程是个坏主意（Why Threads Are A Bad Idea）]]></title>
    <url>%2F2016%2F08%2F09%2Fwhy-multithread-is-a-bad-idea%2F</url>
    <content type="text"><![CDATA[在 Unix编程艺术 中,提到了尽量避免 多线程编程模型, 认为这样只会增加复杂度, 提倡使用多进程, 这样本质上就可以避免多线程『共享内存数据』产生的 “corruotped memory” 问题. 其中, 提到了一篇文章 Why Threads Are A Bad Idea, 对于多线程编程和事件编程分析的非常好, 具体的翻译如下: 1 介绍线程的背景: 在操作系统中出现多线程 逐渐演变成 用户层面的编程工具 被认为是多种问题的一种通用解决方案 每一个程序员都需要成为 一个多线程编程的高手吗？ 根本性的问题:多线程的程序非常难以正确的编写！！！ 替代性的方案:使用事件驱动的编程方法 特别声明: 对于大部分的多线程程序，使用事件驱动是一个更好的选择 只有当使用CPU多核的时候, 才需要使用多线程编程 2 多线程的本质 一般用来管理并发问题 多个独立相互执行的任务 共享的内存 预先的安排机制(Pre-emptive scheduling) 同步机制(synchronization) 3 多线程的用途 操作系统: 对每一个用户进程分配一个内核线程 科学应用程序: 每个CPU分配一个线程(对计算要求性很高的程序) 分布式系统: 进程请求并行(同步记性的I/O操作) GUIs程序 线程对应用户的行为. 在长时间的后台计算过程中仍然可以处理图形展示 多媒体, 动画方面的程序编写 4 多线程有什么问题? 对于一般的程序员而言，难以掌握 即使对于专家，多线程编程也是痛苦的 5 为什么多线程编程很难? Synchronization(同步机制): 必须通过锁来共享数据 忘记了加锁？就会导致 受污染的数据 死锁 依赖锁，会导致循环依赖 每个处理程序等待其他处理程序: 导致系统挂起 6 为什么多线程编程很难? 难以调试: 因为 数据依赖，时间依赖 线程破坏了抽象: 无法设计出模块化的程序 因为锁导致回调无法完成 7 为什么多线程编程很难? 很难达到非常好的性能 简单的锁导致了低并发 而精密的锁又会导致复杂度提升, 降低了一般情况下的性能 OSes限制了性能提升(调度, 环境切换) 线程不受支持 难以 多线程代码(mac, windows) 一些标志库不是线程安全的 内核调用, windows系统不是多线程 很少有多线程编程的调试工具 通常不需要并发场景 8 时间驱动编程 一个执行流进程: 没有CPU的并发 在时间上注册消息(通过回调) 事件轮询等待消息, 调用处理器模型 时间处理器没有抢断 处理器通常是 短生命周期的 9 事件驱动编程被用来干什么 大多数的GUIs编程: 一个处理器对应一个事件 处理器用来执行行为(撤销,删除文件等) 分布式系统 一个处理器用来对应一个输入源 处理进来的请求,返回结果 事件驱动的I/O 来处理 I/O并发 10 事件驱动编程的问题 长时间运行的时间处理器会导致 程序没有反应, 解决办法: 对于长时间运行的程序Fork off子程序处理, 当处理结束后使用事件 打断处理器执行(比如: 事件驱动的I/O) 定期回调 时间处理器中的 事件循环 通过处理器无法维护本地内存状态(处理器必须返回) 没有CPU的并发(不太合适科学计算程序) 事件驱动的编程并不总是被支持 11 多线程编程 VS 事件驱动编程 事件驱动编发编程尽可能的避免 并发, 而多线程编程则倾向于并发： 使用事件驱动编程更加容易: 不用考虑并发, 不用考虑抢占, 不用考虑同步和死锁 只在特定的情况下,才使用复杂的技术栈 使用多线程编程, 即使最简单的程序也需要面对很高的复杂度(full complexity) 使用事件驱动更加容易调试 事件驱动编程只和时间依赖有关, 不需要考虑内部的调度 问题更加容易跟踪: 较慢的按钮点击反应 和 内存数据污染 时候, 前者问题更加容易定位 12 多线程编程 VS 事件驱动编程 在单个CPU上时间驱动程序比线程更加快速 没有锁的覆盖 没有上下文环境的 切换 事件驱动编程更加面向接口编程 多线程提供了真正的并发性 对于多CPU的机器来说，是可以扩展性能 可以长时间的运行处理程序而不需要冻结 13 你需要放弃多线程吗? 不需要的情况: 对于应该程序性能要求很高的服务(比如: 数据库服务器) 但是, 尽可能的避免多线程编程: 对于 GUIs程序, 分布式系统, 性能要求不高的, 使用事件编程, 不是多线程 只有当真正的多核CPU并发需要使用到的时候，使用多线程编程 当使用多线程编程的时候，将多线程编程模块与其他模块进行隔离, 保持大部分代码都是单线程模型 隔离多线程的模块: 14 总结 并发从根本上是很难的, 尽可能的避免 多线程比事件更加强大，但是这种强大的功能很少真正需要 多线程编程比事件编程更加难以写出正确的代码, 只有真正的专家才能掌握 将事件 编程当做基本的开发工具（对于GUIs 和 分布式系统) 只有当性能要求很高的服务时候，才使用 多线程 原文地址:https://web.stanford.edu/~ouster/cgi-bin/papers/threads.pdf]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程, 效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件设计的核心-控制复杂度]]></title>
    <url>%2F2016%2F08%2F05%2Fcomplexity%2F</url>
    <content type="text"><![CDATA[最近重读了《代码大全》这本书, 书中包括的内容非常多, 从软件设计, 代码开发,到 团队管理都有涉及,更像是一个软件编程领域的百科全书. 但是,对于书中提到的一点印象最为深刻, 其实在 《人月神话》和《卓有成效的程序员》这两本经典的书籍中都有提到, 那就是: 软件设计与开发的核心就在于 控制复杂度 这句话的核心其实包括两个问题: 软件开发的本质问题性难题为什么是 复杂度 ？ 如何可以一定努力的降低我们软件系统的复杂度 ？ 杂耍抛球其中, 书中对于软件设计必须控制复杂度的解释原因, 使用了一个非常 有意思的比喻 - 杂耍抛球, 书中的描述如下: 你可以把它想做是一种心理上的杂耍( 边抛边接: 通过轮流抛接使两个或者两个以上的物体同时保持于空中), 程序要求你在空中保持的(精神上的)球越多,你就越可能漏掉其中的某一个, 从而导致设计或者编码上的错误—- 代码大全 当我读到这一段的时候, 感觉这本书的作者真是说出了软件开发者心中的痛啊! 这段话也可以说是整本书的一个核心, 其实《代码大全》这本书的所有部分都是在围绕『如何降低软件开发中的复杂度』这个观点而论述的. 其实, 作者用这种, 杂耍抛球的方式非常形象的比喻了, 我们的大脑（生物结构上）本质的局限性导致的. 曾经美国人有一个非常有名的调查, 人类的大脑短期记忆能够容纳最多的不连续信息数就是7,加而或减二具体可以参考心理学上被引用最多的一篇论文之一 魔数七, 加二或者减二: 人类处理能力的局限性. 而现实问题域中，我们要处理的变量何止是7! 所以我们根本不可能同时让这么多变量一起出现在我们大脑中, 我们大脑的内存其实是非常小的, 这是我们大脑的本质的局限性所导致的. 没有银弹另外从哲学的角度来说, 柏拉图认为, 任何事物都有 两个属性: 本质属性 与 偶然属性. 通过本质的属性我们可以真正的区分不同事物，但是偶尔的属性并不能. 通过此原则, 我们可以将软件行业遇到的问题也分为两类, 那么软件开发过程中 本质性的 难题是什么? 《人月神话》的作者认为, 软件行业中遇到的非根本问题(偶然属性)都会随着时间发展，技术的提升，会逐步解决. 但是 开发中的根本性问题 - 对于现实复杂世界本质的概念的复杂性是无法降低的. 书中写到: 一个软件系统有大量的状态，存在大量不同元素的相互叠加。 这使得软件系统的复杂性以指数的形式增长。而且，这些复杂度是软件系统的根本属性， 而不像数学和物理中那样可以建立简化的模型而忽略复杂的次要因素。 《人月神话》中对于本质的复杂性无法避免, 起了一个名词, 日后基本成了这个行业的通用语: 没有银弹. 作者认为, 不要期望通过一种 万能药 能解决软件开发中所遇到的复杂性问题,复杂性不可避免. 所以 当每次一种新的 编程原因/技术框架/开发模式 等出现的时候, 当有些人大喊可以颠覆以前软件开发中的所有问题的时候的时候, 你就要小心了. 心理默默的告诉自己, 没有银弹! 没有银弹! 没有银弹！(重要的事情说三遍) 降熵其实，软件的复杂度从某种意义上, 用物理学第二定律来理解和加强. 物理学第二定律又叫做,熵定律: 自然过程中，一个孤立系统的总混乱度（即“熵”）不会减小。 换成是软件行业的背景就是, 用《程序员修炼之道》里面的解释就是: 软件的熵总是倾向于最大化的，程序员们称之为“软件腐烂”。 如果, 我们的开发过程中, 不要容忍任何『破窗户』，低劣的设计/错误决策/糟糕的代码,发现一个立即解决, 如果留下，他们会扩散，直至让你的整个系统崩溃. 程序员只有在开发过程中,也只有通过不断的外部做功, 不断主动性的思考和重构你的代码, 通过外部系统注入能量,来降低整个软件系统的熵, 是整个软件系统有序的状态. 为此软件开发行业提出了一些列的原则和指导方法, 重构 / 单元测试/ 模块化设计 / KISS原则/ 面向接口编程/ 模式设计/ 分布式系统等等如此, 其实你都会发现, 这些方法和指导原则,根本都是 告诉程序员, 在软件开发的过程中, 通过这些方法降低软件系统整体的复杂度, 以便后期更好的维护与开发. 当软件复杂度可以得到很好的控制，而不是让软件的熵无限的增长, 那么这个软件系统的寿命也就会很长,更容易后期的维护与扩展. 所以, 我们知道:软件开发中的本质难题是 复杂度, 那么我们在之后开发中 应该时刻的主动思考和做功: 如何通过不断的代码重构降低整体的复杂度. 保持我们的代码熵的最小化. 最后，让我们的代码 永垂不朽 ！]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>编程, 复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RD如何加速自己的成长速度]]></title>
    <url>%2F2016%2F07%2F31%2Frd-grow-up-advice%2F</url>
    <content type="text"><![CDATA[今天参加了一个面试，对方是2011年毕业的一个软件开发人员，工作已经五年左右时间了.但是问了很多的基础的原理都不会, 但是之前又都用过这些技术. 这时候就想到了网上的一个帖子: 为什么你工作是10年还不是专家，而别人两年就可以了? 记得曾经部门老大说了一句话. 人和人的成长速度是不一样的, 有的人两年的成长速度就相当于别人的五年. 慢慢理解了,的确每个人成长的是不一样的. 而如何加速自己的成长是有方法和策略的, 结合个人的经验, 总结几点，也是为了警示自己, 能够在软件开发领域更好的成长. 避免成为一名 水货,毕竟我们这个行业充斥大量的 不合格的选手. 1 不要靠巧合编程曾经面对了很多人的, 有很多年的Java Web开发经验. 但是当你问他一些非常基础的问题的时候，还是答的非常不好. 比如, servlet的生命周期, spring的Bean的加载机制. 更多的候选人还是集中在我知道怎么用这些, 出了问题, 将错误堆栈 google/stackOverflow一下,然后解决问题了,然后就不管了. 下次出现了问题, 还是继续这样的行为. 他们更多的是，copy一下代码, 发现问题google一下, 然后上线,然后就不管了. 到时候出了问题, 是解决不了的. 因为不知道背后的原理,不知道真正的原因. 我们叫这种行为: 靠巧合编程 而高手和专家, 则更多的是从原理和背后的机制去分析问题和解决问题, 而不是浮于表面. 所以RD在日常的开发和学习中, 应该慢慢从 基本会用 慢慢过渡到这 背后的实现原理 是什么, 是真正的掌握整个背后的流程. 2 让正确原则指导自己的行为记得曾经部门老大一次开会, 对下面的小弟语重心长的说了一句: 要做一个正规军,而不是杂牌军. 印象非常深刻. 他解释说: 在战争中, 一般杂牌军肯定是干不过正规军的. 而正规军是什么, 是有一套严格军法和军规(该做什么 和 不该做什么)指导每个人的行为. 而软件行业中, 我们也有根据前人大量的经验总结的 一些原则或者说是 最佳实践. 而高手总是会使用这些 原则指导自己的行为,这也是区分一般选手和高手之间的一条重要指标. 那么软件开发中，我们常说的经常有: 单元测试 代码质量检查 重构 代码review 代码解耦 KISS 原则 控制复杂度 等等以上这些最佳实践, 也许我们只是纯粹的写代码, 不遵守这些也可以, 这样的软件质量不高, 不好维护, 仅仅可以运行, 我们放弃标准, 我们一次又一次的写出 dirty code. 但是 我们的个人永远也很难成长和提高. 软件开发中的. 也就是到个人和团队层面, 是否可以做到: 让正确的原则指导自己的行为 这也是区分高手和一般选手的重要区别. 3 投资个人的知识资产面试的时候，比较喜欢问的是一个问题: 你平时喜欢看哪些书籍? 你一般学习的方法都有哪些? 然后从面试者的一般性回答中都能看出一个人是否有坚持学习的习惯. 其实, 软件行业是一个纯粹的智力行业, 而资产就在于这些员工的个人知识的集合. 而市场上你的工资就是对于你个人资产的评估. 就像 程序员修炼之道 里面提到的一点 Invest Reguarly in Your Knowledge Portfolio 我认为有几个好的方法, 可以持续增加自己的知识资产: 坚持每个月读至少一本书籍 每半年学习一门新的编程语言, 也许你不一定用它，但是你能看到新的视野和思维 坚持写博客,总结学习到的新知识 参加开源软件的开发, 如Github上的开源项目 参加公司新的孵化项目 建立自己的私人藏书(尤其是收藏那些经典的书籍),建议纸质书籍 当你持续和坚持学习几年之后，你就会发现你慢慢的就和你周围的人拉开了差距.]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[把你的知识保存成文本]]></title>
    <url>%2F2016%2F07%2F30%2Fsave-your-knowledge%2F</url>
    <content type="text"><![CDATA[最近在看 卓有成效的程序员, 里面有提到一点: 寻找属于你的完美的编辑器, 并从 里到外去了解它. 选择合适的编辑器, 并将你的文件用纯文本进行保存. 其中，编辑器最好要有一下几个特点: 可扩展 可配置 可插拔 在使用了 evernote /ononote/ notes(mac自带)等软件之后，最终还是找到了我的真爱, 那就是sublime, 用来处理我的日常所有的文本文件和 一些shell程序的编写. 而sublime之所以强大，在于它的插件非常丰富. 可以根据个人的喜好， 0 终极目标让sublime成为你最熟练的编辑工具, 成为你身体的一部分延伸 sublime相关笔记资源收集 网上的说明:http://www.jianshu.com/p/25cdc7d608bb 1 比较好的主题sublime可以安装自己的外观主题，下面是一些比较好的主题的选择. Theme - Spacegrayhttps://github.com/kkga/spacegray/ theme-itg-flat（目前文档使用的脚本）https://github.com/itsthatguy/theme-itg-flat colorsublimehttps://github.com/Colorsublime/Colorsublime-Plugin 2 sublime 高频插件的推荐与使用http://blog.jobbole.com/79326/ 3 比较好的插件 sidebarenhancement PlainTasks 待办的任务清单Sublime的todo-list 非常强大, 可以手工插入各种https://github.com/aziz/PlainTaskshttps://github.com/aziz/PlainTasks/blob/master/messages/Tutorial.todo SublimeREPL相关编辑器，其默认的配置是 http://sublimerepl.readthedocs.io/en/latest/支持 Groovy , clojuer , python, perl, node 等一众脚本编程语言. markdown edit 默认编辑器支持MarkDown编写工具, markdown的 预览，适合于写博客，适合写相应的技术wiki snippts 模板生成代码模板 - 相当于idea中的 live templatehttp://sublimetext.info/docs/en/extensibility/syntaxdefs.html#scopes-and-scope-selectors Waka​Timehttps://packagecontrol.io/packages/WakaTime 4 快捷键快捷键: https://gist.github.com/eteanga/1736542尽量使用快捷键操作，减少鼠标的点击. 让所有的非文本操作.]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术书籍推荐清单]]></title>
    <url>%2F2016%2F07%2F27%2Ftech-booklist%2F</url>
    <content type="text"><![CDATA[比较好的技术书籍整理下作为技术工作一年以来读过的一些比较好的技术书籍，仅供参考 Java 编程语言系列 Java 编程语言(普渡大学教程)大学时候的入门java教材，通俗易懂，书中的例子比较多,非常是适合小白 Think in Java比较详细，不太适合初步入学者, 有些章节并不是很好理解，但是非常全面，但是有一点过于详细. Effective Java适合有一定编程经验之后看，重点 描述 使用Java过程中注意的事项，小心的坑 Java 多线程实践 Java并发编程实践并发编程领域的经典书籍.不用多说，但是第一次看有可能不是很明白，需要反复推敲 Java并发编程的秘密阿里的一个并发技术大牛写的，其中关于JVM 并发编程模型和JDK并发内部原理说的都比较透彻. 代码风格 重构非常好的一本书，绝对立荐. 看完之后，结合Idea Intellij的refactor 功能 代码清洁之道 代码大全 软件构件 maven 实战 Linux Linux shell命令其实作为RD，不像 SRE，对于Linux系统，更多的在于操作层面，所以shell使用的频率远远高于其他方面的Linux知识,这本书对于shell命名的总结比较全面 spring spring in actionspring 使用层面的入门书籍，短小精悍 spring 企业级编程国人写的，比spring in action 更全面一些，包括很多具体的配置. 适合作为一个 工具书籍，放在手边.结合spring io的官方文档，快速查阅，解决问题. spring 内部揭秘对于spring内部原理说明的一本书，国人写的，好像市面上对于spring 内部原理除了这本书也没有其他比较好的书了，书中对于 依赖注入 和 AOP讲解的比较全面，看书的时候一定要和idea的debug模式看源码一起进行，效果比较明显 JVM系列 JVM原理 - 人称小红书 Java性能调优 Javascript系列 javascript语言精粹 jquery node 实战 Java Web java web 大型网站中间件 测试 junit 测试 TDD 测试驱动开发 程序员效率 程序员修炼之道 卓有成效的程序员]]></content>
      <categories>
        <category>list</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本周杂记]]></title>
    <url>%2F2016%2F07%2F27%2Fnotes_08w3%2F</url>
    <content type="text"><![CDATA[Build Your Own Productlink: https://dev.to/sedaily/you-are-not-a-commodity?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=rss 文中相关的链接: https://martinjeeblog.com/2012/11/20/what-is-programmer-anarchy-and-does-it-have-a-future/ how to get startup ideas startup company 1 The hardest battle to fight here is understanding that you should build something. Once you internalize that fact and acquire the necessary skills to prototype, the process of building is a fun exploration, even if you fail along the way. The hardest battle to fight here is understanding that you should build something 构建原型 的能力, 和快速实现原型的能力Most of the money goes to the people who created the assembly line, not the people who maintain it and build on top of it. Clearly, individuals who create an assembly line are rewarded more handsomely. 大部分的钱都去了组装流水线的人的地方了, so sad. individuals who create an assembly line are rewarded more handsomely. As an inexperienced employee, your work is likely to be centered around software maintenance. The company will pitch it to you as fresh and exciting because they see you as naive. But you won’t be building a new product where you have creative control and true responsibility. I do not like to maintain software! Building new software is the perfect activity for someone who likes art, science, business, or adrenaline. Other activities that provide a similar emotional high include drugs, video games, sex, gambling, browsing Facebook, writing music, painting a picture, international diplomacy, raising children, and skydiving. Build new software is the perfect activity for someone who like art, science, business, or adrenaline. 新的技术栈在这里显现React Native: 学习新的创业技能Spring Boot: 快速启动和开发新的软件 The way to get startup ideas is not to try to think of startup ideas. It’s to look for problems, preferably problems you have yourself. Make something people want. We’ve learned a lot since then, but if I were choosing now that’s still the one I’d pick facebook 高效工程师效果 防止干扰 在无人和效率高的时候工作我通常在早上 6 点到 9 点间能够干的事情比一天其他时间能干的都要多，长时间的不受打断至关重要 推迟干扰当你在工作状态时遇到干扰最好的办法之一是推迟干扰。如果你在全神贯注的时候被干扰，那就告诉那个人你稍后会处理，速记一下此事，然后继续工作直到你到达合理的停止点。一旦到达停止点，马上处理完堆积的那些事情。 写更小的diff 每次提交的时候PR更小,采取更小的规模 层次和组织 制定自己的代办清单同时要跟踪管理的来源还包括纸、任务、邮件、日程、清单、高级目标等。不过在确定接下来该干什么，在对任务、邮件的组织和分类方面，许多工程师都有一个 “层次化” 机制。 快速失败和迭代 要养成在不知道结果会怎样的情况下马上写代码的习惯，这样我们就可以更快地迭代，更快看到结果。 不要等着100%的方案出来的时候才写代码,要快速产出效果,快速实验 工作/生活 平衡非线性工作, 非常猛的工作两周，然后 低强度 轻松两周]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程, 效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卓有成效的程序员_笔记]]></title>
    <url>%2F2016%2F07%2F27%2Fbest-coder-book-note%2F</url>
    <content type="text"><![CDATA[卓有成效的程序员 的核心讲的就是利用各种技巧提升程序员的工作效率，其整体内容就是围绕一个原则进行: DRY （Don’t Repeat Yourself）. 其实 在 progmatic progrmaer(程序员修炼之道) 也有类似的分享如何实现DRY, 作者提炼了一下几个核心原则，每个原则下面则是不同的tips. 应该算是一本程序员效率提升之书. 几大法则 加速法则 专注力法则 自动化法则(DRY) 加速法则 - 提高你的生成效率 关注本质，而非形式(not 工具) 快速加载 相应的应用 适用搜索，而非 选择点击 首选键盘，而非鼠标 命令行是与计算机最佳的交互方式 给项目建立快捷键(可以使用alfred的快捷键进行相应的工作) 专注法则 全部专注于当下的工作任务, 只有当前的屏幕和你的思考 全屏,toggle的那种(自带那种模式) 强制不再使用鼠标点击 记住一般使用软件的所有的快捷键 每天有一段时间免于干扰 对于别人的干扰说不 自动化法则 何时应该自动化? 把重复的工作给自动化 -&gt; 自动化编程 ，自动化执行任务，自动化解决问题 写下脚本处理每一项任务，即是可以留底保存，也是为了将来更快的处理问题 本质复杂性与附属复杂性 本质的复杂性与附属的复杂性其实这个问题，在《人月神话》这本书里面已经有讨论过. 本质的复杂性是容易概括的，但是附属的复杂性往往纠缠不清. 那么我们应该关注软件设计中的本质复杂性，尽可能的降低附属复杂性. 如何降低附属复杂性? 通过我们的DRY原则,可以帮助我们. 是否应该自动化1是否应该自动化的关键在于 投资回报率 和缓解风险 平时在公司里面，在一个项目和一个项目的更新过程中，哪些是必须的的动作? 哪些总是重复的，如果对于那些一再重复的内容，我们是否可以进行更新，进行重新操作? 每次都重新创建 项目wiki文档? 是否可以进行项目文档的规范化？ 每次发布都需要登录发布平台，是否可以集成IDEA一起? 一键部署? 线上的问题，是否可以自动的处理工单？….. 所有这些我们经常碰到的问题，我们需要思考，将这些 重复的，单一的工作交给计算机进行处理. 而程序员应该更加关注 创造性的，需要综合和复杂思考的活动. RD 更应该是 制造轮子和工具的人.]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>编程, 效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于恢复博客的想法]]></title>
    <url>%2F2016%2F07%2F27%2Ftst%2F</url>
    <content type="text"><![CDATA[应该认真的从头到尾的去做一件事情，记录自己的工作和生活中的一些想法, 不论想法的对于错，坚持写作，坚持思考，也许这才是最大的意义所在吧. 知行合一.]]></content>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 使用方法]]></title>
    <url>%2F2016%2F06%2F14%2Fhexo-study%2F</url>
    <content type="text"><![CDATA[1. 生成文章hexo new [文章名称] 在_post下面生成相应的文章hexo new page &quot;目录名称&quot; 生成了新的Menu 2. 文章生成打开 /source/_posts 文件夹，打开生成新的文章，开始编辑. 可以使用sublime进行文章编辑 3. 生成静态网页将markdown文件生成html的文件，hexo generate 一键生成 4 部署到服务器在配置文件部署了服务器之后，可以使用 hexo 的一键部署功能, hexo deploy 便可以部署到相应的git 仓库 之后，便可以登录你的域名查看新生成的文章了! 具体的hexo安装和使用说明 https://help.github.com/articles/what-are-github-pages/ github 个人网站托管说明 https://hexo.io/]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
